unit HCNETSDK;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date:  2009-5-20                                            }
{    Generated Time: 17:37:27                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> f:\tddownload\headconv\HCNETSDK.H <=}

{$IFNDEF _HC_NET_SDK_H_}
{$DEFINE _HC_NET_SDK_H_}


{///宏定义 }
const
  MAX_NAMELEN = 16; {//DVR本地登陆名}
const
  MAX_RIGHT = 32; {//设备支持的权限（1-21表示本地权限，13-32表示远程权限）}
const
  NAME_LEN = 32; {//用户名长度}
const
  PASSWD_LEN = 16; {//密码长度}
const
  SERIALNO_LEN = 48; {//序列号长度}
const
  MACADDR_LEN = 6; {//mac地址长度}
const
  MAX_ETHERNET = 2; {//设备可配以太网络}
const
  PATHNAME_LEN = 128; {//路径长度}

const
  MAX_TIMESEGMENT_V30 = 8; {//9000设备最大时间段数}
const
  MAX_TIMESEGMENT = 4; {//8000设备最大时间段数}

const
  MAX_SHELTERNUM = 4; {//8000设备最大遮挡区域数}
const
  MAX_DAYS = 7; {//每周天数}
const
  PHONENUMBER_LEN = 32; {//pppoe拨号号码最大长度}

const
  MAX_DISKNUM_V30 = 33; {//9000设备最大硬盘数/* 最多33个硬盘(包括16个内置SATA硬盘、1个eSATA硬盘和16个NFS盘)*/}
const
  MAX_DISKNUM = 16; {//8000设备最大硬盘数}
const
  MAX_DISKNUM_V10 = 8; {//1.2版本之前版本}

const
  MAX_WINDOW_V30 = 32; {//9000设备本地显示最大播放窗口数}
const
  MAX_WINDOW = 16; {//8000设备最大硬盘数}
const
  MAX_VGA_V30 = 4; {//9000设备最大可接VGA数}
const
  MAX_VGA = 1; {//8000设备最大可接VGA数}

const
  MAX_USERNUM_V30 = 32; {//9000设备最大用户数}
const
  MAX_USERNUM = 16; {//8000设备最大用户数}
const
  MAX_EXCEPTIONNUM_V30 = 32; {//9000设备最大异常处理数}
const
  MAX_EXCEPTIONNUM = 16; {//8000设备最大异常处理数}
const
  MAX_LINK = 6; {//8000设备单通道最大视频流连接数}

const
  MAX_DECPOOLNUM = 4; {//单路解码器每个解码通道最大可循环解码数}
const
  MAX_DECNUM = 4; {//单路解码器的最大解码通道数（实际只有一个，其他三个保留）}
const
  MAX_TRANSPARENTNUM = 2; {//单路解码器可配置最大透明通道数}
const
  MAX_CYCLE_CHAN = 16; {//单路解码器最大轮循通道数}
const
  MAX_DIRNAME_LENGTH = 80; {//最大目录长度}

const
  MAX_STRINGNUM_V30 = 8; {//9000设备最大OSD字符行数数}
const
  MAX_STRINGNUM = 4; {//8000设备最大OSD字符行数数}
const
  MAX_STRINGNUM_EX = 8; {//8000定制扩展}
const
  MAX_AUXOUT_V30 = 16; {//9000设备最大辅助输出数}
const
  MAX_AUXOUT = 4; {//8000设备最大辅助输出数}
const
  MAX_HD_GROUP = 16; {//9000设备最大硬盘组数}
const
  MAX_NFS_DISK = 8; {//8000设备最大NFS硬盘数}

const
  IW_ESSID_MAX_SIZE = 32; {//WIFI的SSID号长度}
const
  IW_ENCODING_TOKEN_MAX = 32; {//WIFI密锁最大字节数}
const
  MAX_SERIAL_NUM = 64; {//最多支持的透明通道路数}
const
  MAX_DDNS_NUMS = 10; {//9000设备最大可配ddns数}
const
  MAX_DOMAIN_NAME = 64; {/* 最大域名长度*/}

const
  MAXPROGRESS = 100; {//回放时的最大百分率}
const
  MAX_SERIALNUM = 2; {//8000设备支持的串口数 1-232， 2-485}
const
  CARDNUM_LEN = 20; {//卡号长度}
const
  MAX_VIDEOOUT_V30 = 4; {//9000设备的视频输出数}
const
  MAX_VIDEOOUT = 2; {//8000设备的视频输出数}

const
  MAX_PRESET_V30 = 256; {/* 9000设备支持的云台预置点数*/}
const
  MAX_TRACK_V30 = 256; {/* 9000设备支持的云台轨迹数*/}
const
  MAX_CRUISE_V30 = 256; {/* 9000设备支持的云台巡航数*/}
const
  MAX_PRESET = 128; {/* 8000设备支持的云台预置点数*/}
const
  MAX_TRACK = 128; {/* 8000设备支持的云台轨迹数*/}
const
  MAX_CRUISE = 128; {/* 8000设备支持的云台巡航数*/}

const
  CRUISE_MAX_PRESET_NUMS = 32; {/* 一条巡航最多的巡航点*/}

const
  MAX_SERIAL_PORT = 8; {//9000设备支持232串口数}
const
  MAX_PREVIEW_MODE = 8; {/* 设备支持最大预览模式数目 1画面,4画面,9画面,16画面....*/}
const
  MAX_MATRIXOUT = 16; {/* 最大模拟矩阵输出个数*/}
const
  LOG_INFO_LEN = 11840; {/* 日志附加信息*/}
const
  DESC_LEN = 16; {/* 云台描述字符串长度*/}
const
  PTZ_PROTOCOL_NUM = 200; {/* 9000最大支持的云台协议数*/}

const
  MAX_AUDIO = 1; {//8000语音对讲通道数}
const
  MAX_AUDIO_V30 = 2; {//9000语音对讲通道数}
const
  MAX_CHANNUM = 16; {//8000设备最大通道数}
const
  MAX_ALARMIN = 16; {//8000设备最大报警输入数}
const
  MAX_ALARMOUT = 4; {//8000设备最大报警输出数}
{///9000 IPC接入 }
const
  MAX_ANALOG_CHANNUM = 32; {//最大32个模拟通道}
const
  MAX_ANALOG_ALARMOUT = 32; {//最大32路模拟报警输出}
const
  MAX_ANALOG_ALARMIN = 32; {//最大32路模拟报警输入}

const
  MAX_IP_DEVICE = 32; {//允许接入的最大IP设备数}
const
  MAX_IP_CHANNEL = 32; {//允许加入的最多IP通道数}
const
  MAX_IP_ALARMIN = 128; {//允许加入的最多报警输入数}
const
  MAX_IP_ALARMOUT = 64; {//允许加入的最多报警输出数}

{+// 最大支持的通道数 最大模拟加上最大IP支持*/ }
const
  MAX_CHANNUM_V30 = (MAX_ANALOG_CHANNUM + MAX_IP_CHANNEL); {//64}
const
  MAX_ALARMOUT_V30 = (MAX_ANALOG_ALARMOUT + MAX_IP_ALARMOUT); {//96}
const
  MAX_ALARMIN_V30 = (MAX_ANALOG_ALARMIN + MAX_IP_ALARMIN); {//160}

{+//******************全局错误码 begin**********************/ }
const
  NET_DVR_FAIL = -1;
const
  NET_DVR_NOERROR = 0; {//没有错误}
const
  NET_DVR_PASSWORD_ERROR = 1; {//用户名密码错误}
const
  NET_DVR_NOENOUGHPRI = 2; {//权限不足}
const
  NET_DVR_NOINIT = 3; {//没有初始化}
const
  NET_DVR_CHANNEL_ERROR = 4; {//通道号错误}
const
  NET_DVR_OVER_MAXLINK = 5; {//连接到DVR的客户端个数超过最大}
const
  NET_DVR_VERSIONNOMATCH = 6; {//版本不匹配}
const
  NET_DVR_NETWORK_FAIL_CONNECT = 7; {//连接服务器失败}
const
  NET_DVR_NETWORK_SEND_ERROR = 8; {//向服务器发送失败}
const
  NET_DVR_NETWORK_RECV_ERROR = 9; {//从服务器接收数据失败}
const
  NET_DVR_NETWORK_RECV_TIMEOUT = 10; {//从服务器接收数据超时}
const
  NET_DVR_NETWORK_ERRORDATA = 11; {//传送的数据有误}
const
  NET_DVR_ORDER_ERROR = 12; {//调用次序错误}
const
  NET_DVR_OPERNOPERMIT = 13; {//无此权限}
const
  NET_DVR_COMMANDTIMEOUT = 14; {//DVR命令执行超时}
const
  NET_DVR_ERRORSERIALPORT = 15; {//串口号错误}
const
  NET_DVR_ERRORALARMPORT = 16; {//报警端口错误}
const
  NET_DVR_PARAMETER_ERROR = 17; {//参数错误}
const
  NET_DVR_CHAN_EXCEPTION = 18; {//服务器通道处于错误状态}
const
  NET_DVR_NODISK = 19; {//没有硬盘}
const
  NET_DVR_ERRORDISKNUM = 20; {//硬盘号错误}
const
  NET_DVR_DISK_FULL = 21; {//服务器硬盘满}
const
  NET_DVR_DISK_ERROR = 22; {//服务器硬盘出错}
const
  NET_DVR_NOSUPPORT = 23; {//服务器不支持}
const
  NET_DVR_BUSY = 24; {//服务器忙}
const
  NET_DVR_MODIFY_FAIL = 25; {//服务器修改不成功}
const
  NET_DVR_PASSWORD_FORMAT_ERROR = 26; {//密码输入格式不正确}
const
  NET_DVR_DISK_FORMATING = 27; {//硬盘正在格式化，不能启动操作}
const
  NET_DVR_DVRNORESOURCE = 28; {//DVR资源不足}
const
  NET_DVR_DVROPRATEFAILED = 29; {//DVR操作失败}
const
  NET_DVR_OPENHOSTSOUND_FAIL = 30; {//打开PC声音失败}
const
  NET_DVR_DVRVOICEOPENED = 31; {//服务器语音对讲被占用}
const
  NET_DVR_TIMEINPUTERROR = 32; {//时间输入不正确}
const
  NET_DVR_NOSPECFILE = 33; {//回放时服务器没有指定的文件}
const
  NET_DVR_CREATEFILE_ERROR = 34; {//创建文件出错}
const
  NET_DVR_FILEOPENFAIL = 35; {//打开文件出错}
const
  NET_DVR_OPERNOTFINISH = 36; {//上次的操作还没有完成}
const
  NET_DVR_GETPLAYTIMEFAIL = 37; {//获取当前播放的时间出错}
const
  NET_DVR_PLAYFAIL = 38; {//播放出错}
const
  NET_DVR_FILEFORMAT_ERROR = 39; {//文件格式不正确}
const
  NET_DVR_DIR_ERROR = 40; {//路径错误}
const
  NET_DVR_ALLOC_RESOURCE_ERROR = 41; {//资源分配错误}
const
  NET_DVR_AUDIO_MODE_ERROR = 42; {//声卡模式错误}
const
  NET_DVR_NOENOUGH_BUF = 43; {//缓冲区太小}
const
  NET_DVR_CREATESOCKET_ERROR = 44; {//创建SOCKET出错}
const
  NET_DVR_SETSOCKET_ERROR = 45; {//设置SOCKET出错}
const
  NET_DVR_MAX_NUM = 46; {//个数达到最大}
const
  NET_DVR_USERNOTEXIST = 47; {//用户不存在}
const
  NET_DVR_WRITEFLASHERROR = 48; {//写FLASH出错}
const
  NET_DVR_UPGRADEFAIL = 49; {//DVR升级失败}
const
  NET_DVR_CARDHAVEINIT = 50; {//解码卡已经初始化过}
const
  NET_DVR_PLAYERFAILED = 51; {//调用播放库中某个函数失败}
const
  NET_DVR_MAX_USERNUM = 52; {//设备端用户数达到最大}
const
  NET_DVR_GETLOCALIPANDMACFAIL = 53; {//获得客户端的IP地址或物理地址失败}
const
  NET_DVR_NOENCODEING = 54; {//该通道没有编码}
const
  NET_DVR_IPMISMATCH = 55; {//IP地址不匹配}
const
  NET_DVR_MACMISMATCH = 56; {//MAC地址不匹配}
const
  NET_DVR_UPGRADELANGMISMATCH = 57; {//升级文件语言不匹配}
const
  NET_DVR_MAX_PLAYERPORT = 58; {//播放器路数达到最大}
const
  NET_DVR_NOSPACEBACKUP = 59; {//备份设备中没有足够空间进行备份}
const
  NET_DVR_NODEVICEBACKUP = 60; {//没有找到指定的备份设备}
const
  NET_DVR_PICTURE_BITS_ERROR = 61; {//图像素位数不符，限24色}
const
  NET_DVR_PICTURE_DIMENSION_ERROR = 62; {//图片高*宽超限， 限128*256}
const
  NET_DVR_PICTURE_SIZ_ERROR = 63; {//图片大小超限，限100K}
const
  NET_DVR_LOADPLAYERSDKFAILED = 64; {//载入当前目录下Player Sdk出错}
const
  NET_DVR_LOADPLAYERSDKPROC_ERROR = 65; {//找不到Player Sdk中某个函数入口}
const
  NET_DVR_LOADDSSDKFAILED = 66; {//载入当前目录下DSsdk出错}
const
  NET_DVR_LOADDSSDKPROC_ERROR = 67; {//找不到DsSdk中某个函数入口}
const
  NET_DVR_DSSDK_ERROR = 68; {//调用硬解码库DsSdk中某个函数失败}
const
  NET_DVR_VOICEMONOPOLIZE = 69; {//声卡被独占}
const
  NET_DVR_JOINMULTICASTFAILED = 70; {//加入多播组失败}
const
  NET_DVR_CREATEDIR_ERROR = 71; {//建立日志文件目录失败}
const
  NET_DVR_BINDSOCKET_ERROR = 72; {//绑定套接字失败}
const
  NET_DVR_SOCKETCLOSE_ERROR = 73; {//socket连接中断，此错误通常是由于连接中断或目的地不可达}
const
  NET_DVR_USERID_ISUSING = 74; {//注销时用户ID正在进行某操作}
const
  NET_DVR_SOCKETLISTEN_ERROR = 75; {//监听失败}
const
  NET_DVR_PROGRAM_EXCEPTION = 76; {//程序异常}
const
  NET_DVR_WRITEFILE_FAILED = 77; {//写文件失败}
const
  NET_DVR_FORMAT_READONLY = 78; {//禁止格式化只读硬盘}
const
  NET_DVR_WITHSAMEUSERNAME = 79; {//用户配置结构中存在相同的用户名}
const
  NET_DVR_DEVICETYPE_ERROR = 80; {/*导入参数时设备型号不匹配*/}
const
  NET_DVR_LANGUAGE_ERROR = 81; {/*导入参数时语言不匹配*/}
const
  NET_DVR_PARAVERSION_ERROR = 82; {/*导入参数时软件版本不匹配*/}
const
  NET_DVR_IPCHAN_NOTALIVE = 83; {/*预览时外接IP通道不在线*/}
const
  NET_DVR_RTSP_SDK_ERROR = 84; {/*加载高清IPC通讯库StreamTransClient失败*/}
const
  NET_DVR_CONVERT_SDK_ERROR = 85; {/*加载转码库CVT_StdToHik失败*/}
const
  NET_DVR_IPC_COUNT_OVERFLOW = 86; {/*超出最大的ip接入通道数*/}

const
  NET_PLAYM4_NOERROR = 500; {//no error}
const
  NET_PLAYM4_PARA_OVER = 501; {//input parameter is invalid;}
const
  NET_PLAYM4_ORDER_ERROR = 502; {//The order of the function to be called is error.}
const
  NET_PLAYM4_TIMER_ERROR = 503; {//Create multimedia clock failed;}
const
  NET_PLAYM4_DEC_VIDEO_ERROR = 504; {//Decode video data failed.}
const
  NET_PLAYM4_DEC_AUDIO_ERROR = 505; {//Decode audio data failed.}
const
  NET_PLAYM4_ALLOC_MEMORY_ERROR = 506; {//Allocate memory failed.}
const
  NET_PLAYM4_OPEN_FILE_ERROR = 507; {//Open the file failed.}
const
  NET_PLAYM4_CREATE_OBJ_ERROR = 508; {//Create thread or event failed}
const
  NET_PLAYM4_CREATE_DDRAW_ERROR = 509; {//Create DirectDraw object failed.}
const
  NET_PLAYM4_CREATE_OFFSCREEN_ERROR = 510; {//failed when creating off-screen surface.}
const
  NET_PLAYM4_BUF_OVER = 511; {//buffer is overflow}
const
  NET_PLAYM4_CREATE_SOUND_ERROR = 512; {//failed when creating audio device.}
const
  NET_PLAYM4_SET_VOLUME_ERROR = 513; {//Set volume failed}
const
  NET_PLAYM4_SUPPORT_FILE_ONLY = 514; {//The function only support play file.}
const
  NET_PLAYM4_SUPPORT_STREAM_ONLY = 515; {//The function only support play stream.}
const
  NET_PLAYM4_SYS_NOT_SUPPORT = 516; {//System not support.}
const
  NET_PLAYM4_FILEHEADER_UNKNOWN = 517; {//No file header.}
const
  NET_PLAYM4_VERSION_INCORRECT = 518; {//The version of decoder and encoder is not adapted.}
const
  NET_PALYM4_INIT_DECODER_ERROR = 519; {//Initialize decoder failed.}
const
  NET_PLAYM4_CHECK_FILE_ERROR = 520; {//The file data is unknown.}
const
  NET_PLAYM4_INIT_TIMER_ERROR = 521; {//Initialize multimedia clock failed.}
const
  NET_PLAYM4_BLT_ERROR = 522; {//Blt failed.}
const
  NET_PLAYM4_UPDATE_ERROR = 523; {//Update failed.}
const
  NET_PLAYM4_OPEN_FILE_ERROR_MULTI = 524; {//openfile error, streamtype is multi}
const
  NET_PLAYM4_OPEN_FILE_ERROR_VIDEO = 525; {//openfile error, streamtype is video}
const
  NET_PLAYM4_JPEG_COMPRESS_ERROR = 526; {//JPEG compress error}
const
  NET_PLAYM4_EXTRACT_NOT_SUPPORT = 527; {//Don't support the version of this file.}
const
  NET_PLAYM4_EXTRACT_DATA_ERROR = 528; {//extract video data failed.}

{+//******************全局错误码 end**********************/ }

{+//************************************************ }
{-NET_DVR_IsSupport()返回值 }
{-1－9位分别表示以下信息（位与是TRUE)表示支持； }
{=************************************************* }
const
  NET_DVR_SUPPORT_DDRAW = $01; {//支持DIRECTDRAW，如果不支持，则播放器不能工作；}
const
  NET_DVR_SUPPORT_BLT = $02; {//显卡支持BLT操作，如果不支持，则播放器不能工作；}
const
  NET_DVR_SUPPORT_BLTFOURCC = $04; {//显卡BLT支持颜色转换，如果不支持，播放器会用软件方法作RGB转换；}
const
  NET_DVR_SUPPORT_BLTSHRINKX = $08; {//显卡BLT支持X轴缩小；如果不支持，系统会用软件方法转换；}
const
  NET_DVR_SUPPORT_BLTSHRINKY = $10; {//显卡BLT支持Y轴缩小；如果不支持，系统会用软件方法转换；}
const
  NET_DVR_SUPPORT_BLTSTRETCHX = $20; {//显卡BLT支持X轴放大；如果不支持，系统会用软件方法转换；}
const
  NET_DVR_SUPPORT_BLTSTRETCHY = $40; {//显卡BLT支持Y轴放大；如果不支持，系统会用软件方法转换；}
const
  NET_DVR_SUPPORT_SSE = $80; {//CPU支持SSE指令，Intel Pentium3以上支持SSE指令；}
const
  NET_DVR_SUPPORT_MMX = $100; {//CPU支持MMX指令集，Intel Pentium3以上支持SSE指令；}

{+//*********************云台控制命令 begin*************************/ }
const
  LIGHT_PWRON = 2; {/* 接通灯光电源*/}
const
  WIPER_PWRON = 3; {/* 接通雨刷开关*/}
const
  FAN_PWRON = 4; {/* 接通风扇开关*/}
const
  HEATER_PWRON = 5; {/* 接通加热器开关*/}
const
  AUX_PWRON1 = 6; {/* 接通辅助设备开关*/}
const
  AUX_PWRON2 = 7; {/* 接通辅助设备开关*/}
const
  SET_PRESET = 8; {/* 设置预置点*/}
const
  CLE_PRESET = 9; {/* 清除预置点*/}

const
  ZOOM_IN = 11; {/* 焦距以速度SS变大(倍率变大)*/}
const
  ZOOM_OUT = 12; {/* 焦距以速度SS变小(倍率变小)*/}
const
  FOCUS_NEAR = 13; {/* 焦点以速度SS前调*/}
const
  FOCUS_FAR = 14; {/* 焦点以速度SS后调*/}
const
  IRIS_OPEN = 15; {/* 光圈以速度SS扩大*/}
const
  IRIS_CLOSE = 16; {/* 光圈以速度SS缩小*/}

const
  TILT_UP = 21; {/* 云台以SS的速度上仰*/}
const
  TILT_DOWN = 22; {/* 云台以SS的速度下俯*/}
const
  PAN_LEFT = 23; {/* 云台以SS的速度左转*/}
const
  PAN_RIGHT = 24; {/* 云台以SS的速度右转*/}
const
  UP_LEFT = 25; {/* 云台以SS的速度上仰和左转*/}
const
  UP_RIGHT = 26; {/* 云台以SS的速度上仰和右转*/}
const
  DOWN_LEFT = 27; {/* 云台以SS的速度下俯和左转*/}
const
  DOWN_RIGHT = 28; {/* 云台以SS的速度下俯和右转*/}
const
  PAN_AUTO = 29; {/* 云台以SS的速度左右自动扫描*/}

const
  FILL_PRE_SEQ = 30; {/* 将预置点加入巡航序列*/}
const
  SET_SEQ_DWELL = 31; {/* 设置巡航点停顿时间*/}
const
  SET_SEQ_SPEED = 32; {/* 设置巡航速度*/}
const
  CLE_PRE_SEQ = 33; {/* 将预置点从巡航序列中删除*/}
const
  STA_MEM_CRUISE = 34; {/* 开始记录轨迹*/}
const
  STO_MEM_CRUISE = 35; {/* 停止记录轨迹*/}
const
  RUN_CRUISE = 36; {/* 开始轨迹*/}
const
  RUN_SEQ = 37; {/* 开始巡航*/}
const
  STOP_SEQ = 38; {/* 停止巡航*/}
const
  GOTO_PRESET = 39; {/* 快球转到预置点*/}

{///海康IP快球 }
const
  SET_SEQ_START = 41; {/* 开始设置巡航*/}
const
  SET_SEQ_END = 42; {/* 结束设置巡航*/}
{+//*********************云台控制命令 end*************************/ }

{+//************************************************ }
{-回放时播放控制命令宏定义 }
{-NET_DVR_PlayBackControl }
{-NET_DVR_PlayControlLocDisplay }
{-NET_DVR_DecPlayBackCtrl的宏定义 }
{-具体支持查看函数说明和代码 }
{=************************************************* }
const
  NET_DVR_PLAYSTART = 1; {//开始播放}
const
  NET_DVR_PLAYSTOP = 2; {//停止播放}
const
  NET_DVR_PLAYPAUSE = 3; {//暂停播放}
const
  NET_DVR_PLAYRESTART = 4; {//恢复播放}
const
  NET_DVR_PLAYFAST = 5; {//快放}
const
  NET_DVR_PLAYSLOW = 6; {//慢放}
const
  NET_DVR_PLAYNORMAL = 7; {//正常速度}
const
  NET_DVR_PLAYFRAME = 8; {//单帧放}
const
  NET_DVR_PLAYSTARTAUDIO = 9; {//打开声音}
const
  NET_DVR_PLAYSTOPAUDIO = 10; {//关闭声音}
const
  NET_DVR_PLAYAUDIOVOLUME = 11; {//调节音量}
const
  NET_DVR_PLAYSETPOS = 12; {//改变文件回放的进度}
const
  NET_DVR_PLAYGETPOS = 13; {//获取文件回放的进度}
const
  NET_DVR_PLAYGETTIME = 14; {//获取当前已经播放的时间(按文件回放的时候有效)}
const
  NET_DVR_PLAYGETFRAME = 15; {//获取当前已经播放的帧数(按文件回放的时候有效)}
const
  NET_DVR_GETTOTALFRAMES = 16; {//获取当前播放文件总的帧数(按文件回放的时候有效)}
const
  NET_DVR_GETTOTALTIME = 17; {//获取当前播放文件总的时间(按文件回放的时候有效)}
//const
  //NET_DVR_THROWBFRAME = 20;{//丢B帧}
const
  NET_DVR_SETSPEED = 24; {//设置码流速度}
const
  NET_DVR_KEEPALIVE = 25; {//保持与设备的心跳(如果回调阻塞，建议2秒发送一次)}

{///远程按键定义如下： }
{+// key value send to CONFIG program*/ }
const
  KEY_CODE_1 = 1;
const
  KEY_CODE_2 = 2;
const
  KEY_CODE_3 = 3;
const
  KEY_CODE_4 = 4;
const
  KEY_CODE_5 = 5;
const
  KEY_CODE_6 = 6;
const
  KEY_CODE_7 = 7;
const
  KEY_CODE_8 = 8;
const
  KEY_CODE_9 = 9;
const
  KEY_CODE_0 = 10;
const
  KEY_CODE_POWER = 11;
const
  KEY_CODE_MENU = 12;
const
  KEY_CODE_ENTER = 13;
const
  KEY_CODE_CANCEL = 14;
const
  KEY_CODE_UP = 15;
const
  KEY_CODE_DOWN = 16;
const
  KEY_CODE_LEFT = 17;
const
  KEY_CODE_RIGHT = 18;
const
  KEY_CODE_EDIT = 19;
const
  KEY_CODE_ADD = 20;
const
  KEY_CODE_MINUS = 21;
const
  KEY_CODE_PLAY = 22;
const
  KEY_CODE_REC = 23;
const
  KEY_CODE_PAN = 24;
const
  KEY_CODE_M = 25;
const
  KEY_CODE_A = 26;
const
  KEY_CODE_F1 = 27;
const
  KEY_CODE_F2 = 28;

{+// for PTZ control*/ }
const
  KEY_PTZ_UP_START = KEY_CODE_UP;
const
  KEY_PTZ_UP_STOP = 32;

const
  KEY_PTZ_DOWN_START = KEY_CODE_DOWN;
const
  KEY_PTZ_DOWN_STOP = 33;

const
  KEY_PTZ_LEFT_START = KEY_CODE_LEFT;
const
  KEY_PTZ_LEFT_STOP = 34;

const
  KEY_PTZ_RIGHT_START = KEY_CODE_RIGHT;
const
  KEY_PTZ_RIGHT_STOP = 35;

const
  KEY_PTZ_AP1_START = KEY_CODE_EDIT; {/* 光圈+*/}
const
  KEY_PTZ_AP1_STOP = 36;

const
  KEY_PTZ_AP2_START = KEY_CODE_PAN; {/* 光圈-*/}
const
  KEY_PTZ_AP2_STOP = 37;

const
  KEY_PTZ_FOCUS1_START = KEY_CODE_A; {/* 聚焦+*/}
const
  KEY_PTZ_FOCUS1_STOP = 38;

const
  KEY_PTZ_FOCUS2_START = KEY_CODE_M; {/* 聚焦-*/}
const
  KEY_PTZ_FOCUS2_STOP = 39;

const
  KEY_PTZ_B1_START = 40; {/* 变倍+*/}
const
  KEY_PTZ_B1_STOP = 41;

const
  KEY_PTZ_B2_START = 42; {/* 变倍-*/}
const
  KEY_PTZ_B2_STOP = 43;

{///9000新增 }
const
  KEY_CODE_11 = 44;
const
  KEY_CODE_12 = 45;
const
  KEY_CODE_13 = 46;
const
  KEY_CODE_14 = 47;
const
  KEY_CODE_15 = 48;
const
  KEY_CODE_16 = 49;

{+//************************参数配置命令 begin*******************************/ }
{///用于NET_DVR_SetDVRConfig和NET_DVR_GetDVRConfig,注意其对应的配置结构 }

const
  NET_DVR_GET_DEVICECFG = 100; {//获取设备参数}
const
  NET_DVR_SET_DEVICECFG = 101; {//设置设备参数}
const
  NET_DVR_GET_NETCFG = 102; {//获取网络参数}
const
  NET_DVR_SET_NETCFG = 103; {//设置网络参数}
const
  NET_DVR_GET_PICCFG = 104; {//获取图象参数}
const
  NET_DVR_SET_PICCFG = 105; {//设置图象参数}
const
  NET_DVR_GET_COMPRESSCFG = 106; {//获取压缩参数}
const
  NET_DVR_SET_COMPRESSCFG = 107; {//设置压缩参数}
const
  NET_DVR_GET_RECORDCFG = 108; {//获取录像时间参数}
const
  NET_DVR_SET_RECORDCFG = 109; {//设置录像时间参数}
const
  NET_DVR_GET_DECODERCFG = 110; {//获取解码器参数}
const
  NET_DVR_SET_DECODERCFG = 111; {//设置解码器参数}
const
  NET_DVR_GET_RS232CFG = 112; {//获取232串口参数}
const
  NET_DVR_SET_RS232CFG = 113; {//设置232串口参数}
const
  NET_DVR_GET_ALARMINCFG = 114; {//获取报警输入参数}
const
  NET_DVR_SET_ALARMINCFG = 115; {//设置报警输入参数}
const
  NET_DVR_GET_ALARMOUTCFG = 116; {//获取报警输出参数}
const
  NET_DVR_SET_ALARMOUTCFG = 117; {//设置报警输出参数}
const
  NET_DVR_GET_TIMECFG = 118; {//获取DVR时间}
const
  NET_DVR_SET_TIMECFG = 119; {//设置DVR时间}
const
  NET_DVR_GET_PREVIEWCFG = 120; {//获取预览参数}
const
  NET_DVR_SET_PREVIEWCFG = 121; {//设置预览参数}
const
  NET_DVR_GET_VIDEOOUTCFG = 122; {//获取视频输出参数}
const
  NET_DVR_SET_VIDEOOUTCFG = 123; {//设置视频输出参数}
const
  NET_DVR_GET_USERCFG = 124; {//获取用户参数}
const
  NET_DVR_SET_USERCFG = 125; {//设置用户参数}
const
  NET_DVR_GET_EXCEPTIONCFG = 126; {//获取异常参数}
const
  NET_DVR_SET_EXCEPTIONCFG = 127; {//设置异常参数}
const
  NET_DVR_GET_ZONEANDDST = 128; {//获取时区和夏时制参数}
const
  NET_DVR_SET_ZONEANDDST = 129; {//设置时区和夏时制参数}
const
  NET_DVR_GET_SHOWSTRING = 130; {//获取叠加字符参数}
const
  NET_DVR_SET_SHOWSTRING = 131; {//设置叠加字符参数}
const
  NET_DVR_GET_EVENTCOMPCFG = 132; {//获取事件触发录像参数}
const
  NET_DVR_SET_EVENTCOMPCFG = 133; {//设置事件触发录像参数}

const
  NET_DVR_GET_AUXOUTCFG = 140; {//获取报警触发辅助输出设置(HS设备辅助输出2006-02-28)}
const
  NET_DVR_SET_AUXOUTCFG = 141; {//设置报警触发辅助输出设置(HS设备辅助输出2006-02-28)}
const
  NET_DVR_GET_PREVIEWCFG_AUX = 142; {//获取-s系列双输出预览参数(-s系列双输出2006-04-13)}
const
  NET_DVR_SET_PREVIEWCFG_AUX = 143; {//设置-s系列双输出预览参数(-s系列双输出2006-04-13)}

const
  NET_DVR_GET_PICCFG_EX = 200; {//获取图象参数(SDK_V14扩展命令)}
const
  NET_DVR_SET_PICCFG_EX = 201; {//设置图象参数(SDK_V14扩展命令)}
const
  NET_DVR_GET_USERCFG_EX = 202; {//获取用户参数(SDK_V15扩展命令)}
const
  NET_DVR_SET_USERCFG_EX = 203; {//设置用户参数(SDK_V15扩展命令)}
const
  NET_DVR_GET_COMPRESSCFG_EX = 204; {//获取压缩参数(SDK_V15扩展命令2006-05-15)}
const
  NET_DVR_SET_COMPRESSCFG_EX = 205; {//设置压缩参数(SDK_V15扩展命令2006-05-15)}


const
  NET_DVR_GET_NETAPPCFG = 222; {//获取网络应用参数 NTP/DDNS/EMAIL}
const
  NET_DVR_SET_NETAPPCFG = 223; {//设置网络应用参数 NTP/DDNS/EMAIL}
const
  NET_DVR_GET_NTPCFG = 224; {//获取网络应用参数 NTP}
const
  NET_DVR_SET_NTPCFG = 225; {//设置网络应用参数 NTP}
const
  NET_DVR_GET_DDNSCFG = 226; {//获取网络应用参数 DDNS}
const
  NET_DVR_SET_DDNSCFG = 227; {//设置网络应用参数 DDNS}
{///对应NET_DVR_EMAILPARA }
const
  NET_DVR_GET_EMAILCFG = 228; {//获取网络应用参数 EMAIL}
const
  NET_DVR_SET_EMAILCFG = 229; {//设置网络应用参数 EMAIL}

const
  NET_DVR_GET_NFSCFG = 230; {/* NFS disk config*/}
const
  NET_DVR_SET_NFSCFG = 231; {/* NFS disk config*/}

const
  NET_DVR_GET_SHOWSTRING_EX = 238; {//获取叠加字符参数扩展(支持8条字符)}
const
  NET_DVR_SET_SHOWSTRING_EX = 239; {//设置叠加字符参数扩展(支持8条字符)}
const
  NET_DVR_GET_NETCFG_OTHER = 244; {//获取网络参数(多路解码器)}
const
  NET_DVR_SET_NETCFG_OTHER = 245; {//设置网络参数(多路解码器)}

{///对应NET_DVR_EMAILCFG结构 }
const
  NET_DVR_GET_EMAILPARACFG = 250; {//Get EMAIL parameters}
const
  NET_DVR_SET_EMAILPARACFG = 251; {//Setup EMAIL parameters}


const
  NET_DVR_GET_DDNSCFG_EX = 274; {//获取扩展DDNS参数}
const
  NET_DVR_SET_DDNSCFG_EX = 275; {//设置扩展DDNS参数}

const
  NET_DVR_SET_PTZPOS = 292; {//云台设置PTZ位置}
const
  NET_DVR_GET_PTZPOS = 293; {//云台获取PTZ位置}
const
  NET_DVR_GET_PTZSCOPE = 294; {//云台获取PTZ范围}

{/// }
const
  NET_DVR_GET_ALLHDCFG = 300; {//}


{+//**************************DS9000新增命令(_V30) begin*****************************/ }
{///网络(NET_DVR_NETCFG_V30结构) }
const
  NET_DVR_GET_NETCFG_V30 = 1000; {//获取网络参数}
const
  NET_DVR_SET_NETCFG_V30 = 1001; {//设置网络参数}

{///图象(NET_DVR_PICCFG_V30结构) }
const
  NET_DVR_GET_PICCFG_V30 = 1002; {//获取图象参数}
const
  NET_DVR_SET_PICCFG_V30 = 1003; {//设置图象参数}

{///录像时间(NET_DVR_RECORD_V30结构) }
const
  NET_DVR_GET_RECORDCFG_V30 = 1004; {//获取录像参数}
const
  NET_DVR_SET_RECORDCFG_V30 = 1005; {//设置录像参数}

{///用户(NET_DVR_USER_V30结构) }
const
  NET_DVR_GET_USERCFG_V30 = 1006; {//获取用户参数}
const
  NET_DVR_SET_USERCFG_V30 = 1007; {//设置用户参数}

{///9000DDNS参数配置(NET_DVR_DDNSPARA_V30结构) }
const
  NET_DVR_GET_DDNSCFG_V30 = 1010; {//获取DDNS(9000扩展)}
const
  NET_DVR_SET_DDNSCFG_V30 = 1011; {//设置DDNS(9000扩展)}

{///EMAIL功能(NET_DVR_EMAILCFG_V30结构) }
const
  NET_DVR_GET_EMAILCFG_V30 = 1012; {//获取EMAIL参数}
const
  NET_DVR_SET_EMAILCFG_V30 = 1013; {//设置EMAIL参数}

{///巡航参数 (NET_DVR_CRUISE_PARA结构) }
const
  NET_DVR_GET_CRUISE = 1020;
const
  NET_DVR_SET_CRUISE = 1021;


{///报警输入结构参数 (NET_DVR_ALARMINCFG_V30结构) }
const
  NET_DVR_GET_ALARMINCFG_V30 = 1024;
const
  NET_DVR_SET_ALARMINCFG_V30 = 1025;

{///报警输出结构参数 (NET_DVR_ALARMOUTCFG_V30结构) }
const
  NET_DVR_GET_ALARMOUTCFG_V30 = 1026;
const
  NET_DVR_SET_ALARMOUTCFG_V30 = 1027;

{///视频输出结构参数 (NET_DVR_VIDEOOUT_V30结构) }
const
  NET_DVR_GET_VIDEOOUTCFG_V30 = 1028;
const
  NET_DVR_SET_VIDEOOUTCFG_V30 = 1029;

{///叠加字符结构参数 (NET_DVR_SHOWSTRING_V30结构) }
const
  NET_DVR_GET_SHOWSTRING_V30 = 1030;
const
  NET_DVR_SET_SHOWSTRING_V30 = 1031;

{///异常结构参数 (NET_DVR_EXCEPTION_V30结构) }
const
  NET_DVR_GET_EXCEPTIONCFG_V30 = 1034;
const
  NET_DVR_SET_EXCEPTIONCFG_V30 = 1035;

{///串口232结构参数 (NET_DVR_RS232CFG_V30结构) }
const
  NET_DVR_GET_RS232CFG_V30 = 1036;
const
  NET_DVR_SET_RS232CFG_V30 = 1037;

{///压缩参数 (NET_DVR_COMPRESSIONCFG_V30结构) }
const
  NET_DVR_GET_COMPRESSCFG_V30 = 1040;
const
  NET_DVR_SET_COMPRESSCFG_V30 = 1041;

{///获取485解码器参数 (NET_DVR_DECODERCFG_V30结构) }
const
  NET_DVR_GET_DECODERCFG_V30 = 1042; {//获取解码器参数}
const
  NET_DVR_SET_DECODERCFG_V30 = 1043; {//设置解码器参数}

{///获取预览参数 (NET_DVR_PREVIEWCFG_V30结构) }
const
  NET_DVR_GET_PREVIEWCFG_V30 = 1044; {//获取预览参数}
const
  NET_DVR_SET_PREVIEWCFG_V30 = 1045; {//设置预览参数}

{///辅助预览参数 (NET_DVR_PREVIEWCFG_AUX_V30结构) }
const
  NET_DVR_GET_PREVIEWCFG_AUX_V30 = 1046; {//获取辅助预览参数}
const
  NET_DVR_SET_PREVIEWCFG_AUX_V30 = 1047; {//设置辅助预览参数}

{///IP接入配置参数 （NET_DVR_IPPARACFG结构） }
const
  NET_DVR_GET_IPPARACFG = 1048; {//获取IP接入配置信息}
const
  NET_DVR_SET_IPPARACFG = 1049; {//设置IP接入配置信息}

{///IP报警输入接入配置参数 （NET_DVR_IPALARMINCFG结构） }
const
  NET_DVR_GET_IPALARMINCFG = 1050; {//获取IP报警输入接入配置信息}
const
  NET_DVR_SET_IPALARMINCFG = 1051; {//设置IP报警输入接入配置信息}

{///IP报警输出接入配置参数 （NET_DVR_IPALARMOUTCFG结构） }
const
  NET_DVR_GET_IPALARMOUTCFG = 1052; {//获取IP报警输出接入配置信息}
const
  NET_DVR_SET_IPALARMOUTCFG = 1053; {//设置IP报警输出接入配置信息}

{///硬盘管理的参数获取 (NET_DVR_HDCFG结构) }
const
  NET_DVR_GET_HDCFG = 1054; {//获取硬盘管理配置参数}
const
  NET_DVR_SET_HDCFG = 1055; {//设置硬盘管理配置参数}
{///盘组管理的参数获取 (NET_DVR_HDGROUP_CFG结构) }
const
  NET_DVR_GET_HDGROUP_CFG = 1056; {//获取盘组管理配置参数}
const
  NET_DVR_SET_HDGROUP_CFG = 1057; {//设置盘组管理配置参数}

{///设备编码类型配置(NET_DVR_COMPRESSION_AUDIO结构) }
const
  NET_DVR_GET_COMPRESSCFG_AUD = 1058; {//获取设备语音对讲编码参数}
const
  NET_DVR_SET_COMPRESSCFG_AUD = 1059; {//设置设备语音对讲编码参数}
{+//**************************DS9000新增命令(_V30) end*****************************/ }

{+//************************参数配置命令 end*******************************/ }


{+//******************查找文件和日志函数返回值*************************/ }
const
  NET_DVR_FILE_SUCCESS = 1000; {//获得文件信息}
const
  NET_DVR_FILE_NOFIND = 1001; {//没有文件}
const
  NET_DVR_ISFINDING = 1002; {//正在查找文件}
const
  NET_DVR_NOMOREFILE = 1003; {//查找文件时没有更多的文件}
const
  NET_DVR_FILE_EXCEPTION = 1004; {//查找文件时异常}

{+//********************回调函数类型 begin************************/ }
const
  COMM_ALARM = $1100; {//8000报警信息主动上传}
const
  COMM_TRADEINFO = $1500; {//ATMDVR主动上传交易信息}

const
  COMM_ALARM_V30 = $4000; {//9000报警信息主动上传}
const
  COMM_IPCCFG = $4001; {//9000设备IPC接入配置改变报警信息主动上传}


{+//************操作异常类型(消息方式, 回调方式(保留))****************/ }
const
  EXCEPTION_EXCHANGE = $8000; {//用户交互时异常}
const
  EXCEPTION_AUDIOEXCHANGE = $8001; {//语音对讲异常}
const
  EXCEPTION_ALARM = $8002; {//报警异常}
const
  EXCEPTION_PREVIEW = $8003; {//网络预览异常}
const
  EXCEPTION_SERIAL = $8004; {//透明通道异常}
const
  EXCEPTION_RECONNECT = $8005; {//预览时重连}
const
  EXCEPTION_ALARMRECONNECT = $8006; {//报警时重连}
const
  EXCEPTION_SERIALRECONNECT = $8007; {//透明通道重连}
const
  EXCEPTION_PLAYBACK = $8010; {//回放异常}
const
  EXCEPTION_DISKFMT = $8011; {//硬盘格式化}

{+//*******************预览回调函数*********************/ }
const
  NET_DVR_SYSHEAD = 1; {//系统头数据}
const
  NET_DVR_STREAMDATA = 2; {//视频流数据（包括复合流和音视频分开的视频流数据）}
const
  NET_DVR_AUDIOSTREAMDATA = 3; {//音频流数据}
const
  NET_DVR_STD_VIDEODATA = 4; {//标准视频流数据}
const
  NET_DVR_STD_AUDIODATA = 5; {//标准音频流数据}

{///回调预览中的状态和消息 }
const
  NET_DVR_REALPLAYEXCEPTION = 111; {//预览异常}
const
  NET_DVR_REALPLAYNETCLOSE = 112; {//预览时连接断开}
const
  NET_DVR_REALPLAY5SNODATA = 113; {//预览5s没有收到数据}
const
  NET_DVR_REALPLAYRECONNECT = 114; {//预览重连}

{+//*******************回放回调函数*********************/ }
const
  NET_DVR_PLAYBACKOVER = 101; {//回放数据播放完毕}
const
  NET_DVR_PLAYBACKEXCEPTION = 102; {//回放异常}
const
  NET_DVR_PLAYBACKNETCLOSE = 103; {//回放时候连接断开}
const
  NET_DVR_PLAYBACK5SNODATA = 104; {//回放5s没有收到数据}

{+//********************回调函数类型 end************************/ }


{///设备型号(DVR类型) }
{+// 设备类型*/ }
const
  DVR = 1; {/*对尚未定义的dvr类型返回NETRET_DVR*/}
const
  ATMDVR = 2; {/*atm dvr*/}
const
  DVS = 3; {/*DVS*/}
const
  DEC = 4; {/* 6001D*/}
const
  ENC_DEC = 5; {/* 6001F*/}
const
  DVR_HC = 6; {/*8000HC*/}
const
  DVR_HT = 7; {/*8000HT*/}
const
  DVR_HF = 8; {/*8000HF*/}
const
  DVR_HS = 9; {/* 8000HS DVR(no audio)*/}
const
  DVR_HTS = 10; {/* 8016HTS DVR(no audio)*/}
const
  DVR_HB = 11; {/* HB DVR(SATA HD)*/}
const
  DVR_HCS = 12; {/* 8000HCS DVR*/}
const
  DVS_A = 13; {/* 带ATA硬盘的DVS*/}
const
  DVR_HC_S = 14; {/* 8000HC-S*/}
const
  DVR_HT_S = 15; {/* 8000HT-S*/}
const
  DVR_HF_S = 16; {/* 8000HF-S*/}
const
  DVR_HS_S = 17; {/* 8000HS-S*/}
const
  ATMDVR_S = 18; {/* ATM-S*/}
const
  LOWCOST_DVR = 19; {/*7000H系列*/}
const
  DEC_MAT = 20; {/*多路解码器*/}
const
  DVR_MOBILE = 21; {/* mobile DVR*/}
const
  DVR_HD_S = 22; {/* 8000HD-S*/}
const
  DVR_HD_SL = 23; {/* 8000HD-SL*/}
const
  DVR_HC_SL = 24; {/* 8000HC-SL*/}
const
  DVR_HS_ST = 25; {/* 8000HS_ST*/}
const
  DVS_HW = 26; {/* 6000HW*/}
const
  IPCAM = 30; {/*IP 摄像机*/}
const
  MEGA_IPCAM = 31; {/*X52MF系列,752MF,852MF*/}
const
  IPCAM_X62MF = 32; {/*X62MF系列可接入9000设备,762MF,862MF*/}
const
  IPDOME = 40; {/*IP 快球*/}
const
  IPMOD = 50; {/*IP 模块*/}
const
  DS71XX_H = 71; {/*71XX*/}
const
  DS81XX_HS_S = 80; {/*DS81XX_HS_S*/}
const
  DS90XX_HF_S = 90; {/*DS90XX_HF_S*/}
const
  DS91XX_HF_S = 91; {/*DS91XX_HF_S*/}
const
  DS91XX_HD_S = 92; {/*91XXHD-S(MD)*/}


{+//*********************设备类型 end***********************/ }

{+//************************************************ }
{-参数配置结构、参数(其中_V30为9000新增) }
{=************************************************* }

{////////////////////////////////////////////////////////////////////////// }
{///校时结构参数 }
type
  NET_DVR_TIME = record
    dwYear: LongInt;
    dwMonth: LongInt;
    dwDay: LongInt;
    dwHour: LongInt;
    dwMinute: LongInt;
    dwSecond: LongInt;
  end {NET_DVR_TIME};
  LPNET_DVR_TIME = ^NET_DVR_TIME;

{///时间段(子结构) }
type
  NET_DVR_SCHEDTIME = record
{///开始时间 }
    byStartHour: BYTE;
    byStartMin: BYTE;
{///结束时间 }
    byStopHour: BYTE;
    byStopMin: BYTE;
  end {NET_DVR_SCHEDTIME};
  LPNET_DVR_SCHEDTIME = ^NET_DVR_SCHEDTIME;

{+//设备报警和异常处理方式*/ }
const
  NOACTION = $0; {/*无响应*/}
const
  WARNONMONITOR = $1; {/*监视器上警告*/}
const
  WARNONAUDIOOUT = $2; {/*声音警告*/}
const
  UPTOCENTER = $4; {/*上传中心*/}
const
  TRIGGERALARMOUT = $8; {/*触发报警输出*/}

{///报警和异常处理结构(子结构)(多处使用)(9000扩展) }
type
  NET_DVR_HANDLEEXCEPTION_V30 = record
    dwHandleType: LongInt;
{=处理方式,处理方式的"或"结果 }
{+//0x00: 无响应*/ }
{+//0x01: 监视器上警告*/ }
{+//0x02: 声音警告*/ }
{+//0x04: 上传中心*/ }
{+//0x08: 触发报警输出*/ }
{+//0x10: Jpeg抓图并上传EMail*/ }
    byRelAlarmOut: array[0..MAX_ALARMOUT_V30 - 1] of BYTE;
{///报警触发的输出通道,报警触发的输出,为1表示触发该输出 }
  end {NET_DVR_HANDLEEXCEPTION_V30};
  LPNET_DVR_HANDLEEXCEPTION_V30 = ^NET_DVR_HANDLEEXCEPTION_V30;

{///报警和异常处理结构(子结构)(多处使用) }
type
  NET_DVR_HANDLEEXCEPTION = record
    dwHandleType: LongInt;
{=处理方式,处理方式的"或"结果 }
{+//0x00: 无响应*/ }
{+//0x01: 监视器上警告*/ }
{+//0x02: 声音警告*/ }
{+//0x04: 上传中心*/ }
{+//0x08: 触发报警输出*/ }
{+//0x10: Jpeg抓图并上传EMail*/ }
    byRelAlarmOut: array[0..MAX_ALARMOUT - 1] of BYTE;
  end {NET_DVR_HANDLEEXCEPTION};
  LPNET_DVR_HANDLEEXCEPTION = ^NET_DVR_HANDLEEXCEPTION;

{///DVR设备参数 }
type
  NET_DVR_DEVICECFG = record
    dwSize: LongInt;
    sDVRName: array[0..NAME_LEN - 1] of BYTE;
    dwDVRID: LongInt;
    dwRecycleRecord: LongInt;
{///以下不可更改 }
    sSerialNumber: array[0..SERIALNO_LEN - 1] of BYTE;
    dwSoftwareVersion: LongInt;
    dwSoftwareBuildDate: LongInt;
    dwDSPSoftwareVersion: LongInt;
    dwDSPSoftwareBuildDate: LongInt;
    dwPanelVersion: LongInt;
    dwHardwareVersion: LongInt;
    byAlarmInPortNum: BYTE;
    byAlarmOutPortNum: BYTE;
    byRS232Num: BYTE;
    byRS485Num: BYTE;
    byNetworkPortNum: BYTE;
    byDiskCtrlNum: BYTE;
    byDiskNum: BYTE;
    byDVRType: BYTE;
    byChanNum: BYTE;
    byStartChan: BYTE;
    byDecordChans: BYTE;
    byVGANum: BYTE;
    byUSBNum: BYTE;
    byAuxoutNum: BYTE;
    byAudioNum: BYTE;
    byIPChanNum: BYTE;
  end {NET_DVR_DEVICECFG};
  LPNET_DVR_DEVICECFG = ^NET_DVR_DEVICECFG;

{+// }
{-IP地址 }
{= }
type
  NET_DVR_IPADDR = record
    sIpV4: array[0..16 - 1] of Char;
{= IPv4地址 }
    byRes: array[0..128 - 1] of BYTE;
{= 保留 }
  end {NET_DVR_IPADDR};
  LPNET_DVR_IPADDR = ^NET_DVR_IPADDR;


{+// }
{-网络数据结构(子结构)(9000扩展) }
{= }
type
  NET_DVR_ETHERNET_V30 = record
    struDVRIP: NET_DVR_IPADDR;
    struDVRIPMask: NET_DVR_IPADDR;
    dwNetInterface: LongInt;
    wDVRPort: Word;
    wMTU: Word;
    byMACAddr: array[0..MACADDR_LEN - 1] of BYTE;
  end {NET_DVR_ETHERNET_V30};
  LPNET_DVR_ETHERNET_V30 = ^NET_DVR_ETHERNET_V30;

{+// }
{-网络数据结构(子结构) }
{= }
type
  NET_DVR_ETHERNET = record
    sDVRIP: array[0..16 - 1] of Char;
    sDVRIPMask: array[0..16 - 1] of Char;
    dwNetInterface: LongInt;
    wDVRPort: Word;
    byMACAddr: array[0..MACADDR_LEN - 1] of BYTE;
  end {NET_DVR_ETHERNET};

{///pppoe结构 }
type
  NET_DVR_PPPOECFG = record
    dwPPPOE: LongInt;
    sPPPoEUser: array[0..NAME_LEN - 1] of BYTE;
    sPPPoEPassword: array[0..PASSWD_LEN - 1] of Char;
    struPPPoEIP: NET_DVR_IPADDR;
  end {NET_DVR_PPPOECFG};
  LPNET_DVR_PPPOECFG = ^NET_DVR_PPPOECFG;

{///网络配置结构(9000扩展) }
type
  NET_DVR_NETCFG_V30 = record
    dwSize: LongInt;
    struEtherNet: array[0..MAX_ETHERNET - 1] of NET_DVR_ETHERNET_V30;
    struRes1: array[0..2 - 1] of NET_DVR_IPADDR;
{=保留 }
    struAlarmHostIpAddr: NET_DVR_IPADDR;
{= 报警主机IP地址 }
    wRes2: array[0..2 - 1] of Word;
{= 保留 }
    wAlarmHostIpPort: Word;
{= 报警主机端口号 }
    byUseDhcp: BYTE;
{= 是否启用DHCP 0xff-无效 0-不启用 1-启用 }
    byRes3: BYTE;
    struDnsServer1IpAddr: NET_DVR_IPADDR;
{= 域名服务器1的IP地址 }
    struDnsServer2IpAddr: NET_DVR_IPADDR;
{= 域名服务器2的IP地址 }
    byIpResolver: array[0..MAX_DOMAIN_NAME - 1] of BYTE;
{= IP解析服务器域名或IP地址 }
    wIpResolverPort: Word;
{= IP解析服务器端口号 }
    wHttpPortNo: Word;
{= HTTP端口号 }
    struMulticastIpAddr: NET_DVR_IPADDR;
{= 多播组地址 }
    struGatewayIpAddr: NET_DVR_IPADDR;
{= 网关地址 }
    struPPPoE: NET_DVR_PPPOECFG;
    byRes: array[0..64 - 1] of BYTE;
  end {NET_DVR_NETCFG_V30};
  LPNET_DVR_NETCFG_V30 = ^NET_DVR_NETCFG_V30;

{///网络配置结构 }
type
  NET_DVR_NETCFG = record
    dwSize: LongInt;
    struEtherNet: array[0..MAX_ETHERNET - 1] of NET_DVR_ETHERNET;
{= 以太网口 }
    sManageHostIP: array[0..16 - 1] of Char;
    wManageHostPort: Word;
    sIPServerIP: array[0..16 - 1] of Char;
    sMultiCastIP: array[0..16 - 1] of Char;
    sGatewayIP: array[0..16 - 1] of Char;
    sNFSIP: array[0..16 - 1] of Char;
    sNFSDirectory: array[0..PATHNAME_LEN - 1] of BYTE;
    dwPPPOE: LongInt;
    sPPPoEUser: array[0..NAME_LEN - 1] of BYTE;
    sPPPoEPassword: array[0..PASSWD_LEN - 1] of Char;
    sPPPoEIP: array[0..16 - 1] of Char;
    wHttpPort: Word;
  end {NET_DVR_NETCFG};
  LPNET_DVR_NETCFG = ^NET_DVR_NETCFG;

{///通道图象结构 }
{///移动侦测(子结构)(9000扩展) }
type
  NET_DVR_MOTION_V30 = record
    byMotionScope: array[0..63, 0..95] of BYTE;
{=侦测区域,0-96位,表示64行,共有96*64个小宏块,为1表示是移动侦测区域,0-表示不是 }
    byMotionSensitive: BYTE;
{=移动侦测灵敏度, 0 - 5,越高越灵敏,oxff关闭 }
    byEnableHandleMotion: BYTE;
{= 是否处理移动侦测 0－否 1－是 }
    byPrecision: BYTE;
{= 移动侦测算法的进度: 0--16*16, 1--32*32, 2--64*64 ... }
    reservedData: Char;
    struMotionHandleType: NET_DVR_HANDLEEXCEPTION_V30;
{= 处理方式 }
    struAlarmTime: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT_V30 - 1] of NET_DVR_SCHEDTIME;
{=布防时间 }
    byRelRecordChan: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 报警触发的录象通道 }
  end {NET_DVR_MOTION_V30};
  LPNET_DVR_MOTION_V30 = ^NET_DVR_MOTION_V30;

{///移动侦测(子结构) }
type
  NET_DVR_MOTION = record
    byMotionScope: array[0..17, 0..22 - 1] of BYTE;
{=侦测区域,共有22*18个小宏块,为1表示改宏块是移动侦测区域,0-表示不是 }
    byMotionSensitive: BYTE;
{=移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭 }
    byEnableHandleMotion: BYTE;
{= 是否处理移动侦测 }
    reservedData: array[0..2 - 1] of Char;
    strMotionHandleType: NET_DVR_HANDLEEXCEPTION;
{= 处理方式 }
    struAlarmTime: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT - 1] of NET_DVR_SCHEDTIME;
    byRelRecordChan: array[0..MAX_CHANNUM - 1] of BYTE;
  end {NET_DVR_MOTION};
  LPNET_DVR_MOTION = ^NET_DVR_MOTION;

{///遮挡报警(子结构)(9000扩展) 区域大小704*576 }
type
  NET_DVR_HIDEALARM_V30 = record
    dwEnableHideAlarm: LongInt;
{= 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度 }
    wHideAlarmAreaTopLeftX: Word;
{= 遮挡区域的x坐标 }
    wHideAlarmAreaTopLeftY: Word;
{= 遮挡区域的y坐标 }
    wHideAlarmAreaWidth: Word;
{= 遮挡区域的宽 }
    wHideAlarmAreaHeight: Word;
{=遮挡区域的高 }
    strHideAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;
{= 处理方式 }
    struAlarmTime: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT_V30 - 1] of NET_DVR_SCHEDTIME;
  end {NET_DVR_HIDEALARM_V30};
  LPNET_DVR_HIDEALARM_V30 = ^NET_DVR_HIDEALARM_V30;
{///遮挡报警(子结构) 区域大小704*576 }
type
  NET_DVR_HIDEALARM = record
    dwEnableHideAlarm: LongInt;
{= 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度 }
    wHideAlarmAreaTopLeftX: Word;
{= 遮挡区域的x坐标 }
    wHideAlarmAreaTopLeftY: Word;
{= 遮挡区域的y坐标 }
    wHideAlarmAreaWidth: Word;
{= 遮挡区域的宽 }
    wHideAlarmAreaHeight: Word;
{=遮挡区域的高 }
    strHideAlarmHandleType: NET_DVR_HANDLEEXCEPTION;
{= 处理方式 }
    struAlarmTime: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT - 1] of NET_DVR_SCHEDTIME;
  end {NET_DVR_HIDEALARM};
  LPNET_DVR_HIDEALARM = ^NET_DVR_HIDEALARM;

{///信号丢失报警(子结构)(9000扩展) }
type
  NET_DVR_VILOST_V30 = record
    byEnableHandleVILost: BYTE;
{= 是否处理信号丢失报警 }
    strVILostHandleType: NET_DVR_HANDLEEXCEPTION_V30;
{= 处理方式 }
    struAlarmTime: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT_V30 - 1] of NET_DVR_SCHEDTIME;
  end {NET_DVR_VILOST_V30};
  LPNET_DVR_VILOST_V30 = ^NET_DVR_VILOST_V30;

{///信号丢失报警(子结构) }
type
  NET_DVR_VILOST = record
    byEnableHandleVILost: BYTE;
{= 是否处理信号丢失报警 }
    strVILostHandleType: NET_DVR_HANDLEEXCEPTION;
{= 处理方式 }
    struAlarmTime: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT - 1] of NET_DVR_SCHEDTIME;
  end {NET_DVR_VILOST};
  LPNET_DVR_VILOST = ^NET_DVR_VILOST;

{///遮挡区域(子结构) }
type
  NET_DVR_SHELTER = record
    wHideAreaTopLeftX: Word;
{= 遮挡区域的x坐标 }
    wHideAreaTopLeftY: Word;
{= 遮挡区域的y坐标 }
    wHideAreaWidth: Word;
{= 遮挡区域的宽 }
    wHideAreaHeight: Word;
{=遮挡区域的高 }
  end {NET_DVR_SHELTER};
  LPNET_DVR_SHELTER = ^NET_DVR_SHELTER;

type
  NET_DVR_COLOR = record
    byBrightness: BYTE;
{=亮度,0-255 }
    byContrast: BYTE;
{=对比度,0-255 }
    bySaturation: BYTE;
{=饱和度,0-255 }
    byHue: BYTE;
{=色调,0-255 }
  end {NET_DVR_COLOR};
  LPNET_DVR_COLOR = ^NET_DVR_COLOR;


{///通道图象结构(9000扩展) }
type
  NET_DVR_PICCFG_V30 = record
    dwSize: LongInt;
    sChanName: array[0..NAME_LEN - 1] of BYTE;
    dwVideoFormat: LongInt;
{= 只读 视频制式 1-NTSC 2-PAL }
    struColor: NET_DVR_COLOR;
    reservedData: array[0..60 - 1] of CHAR;
{=保留 }
{///显示通道名 }
    dwShowChanName: LongInt;
    wShowNameTopLeftX: Word;
{= 通道名称显示位置的x坐标 }
    wShowNameTopLeftY: Word;
{= 通道名称显示位置的y坐标 }
{///视频信号丢失报警 }
    struVILost: NET_DVR_VILOST_V30;
    struRes: NET_DVR_VILOST_V30;
{=保留 }
{///移动侦测 }
    struMotion: NET_DVR_MOTION_V30;
{///遮挡报警 }
    struHideAlarm: NET_DVR_HIDEALARM_V30;
{///遮挡 区域大小704*576 }
    dwEnableHide: LongInt;
{= 是否启动遮挡 ,0-否,1-是 }
    struShelter: array[0..MAX_SHELTERNUM - 1] of NET_DVR_SHELTER;
{///OSD }
    dwShowOsd: LongInt;
    wOSDTopLeftX: Word;
{= OSD的x坐标 }
    wOSDTopLeftY: Word;
{= OSD的y坐标 }
    byOSDType: BYTE;
{= OSD类型(主要是年月日格式) }
{+// 0: XXXX-XX-XX 年月日*/ }
{+// 1: XX-XX-XXXX 月日年*/ }
{+// 2: XXXX年XX月XX日*/ }
{+// 3: XX月XX日XXXX年*/ }
{+// 4: XX-XX-XXXX 日月年*/ }
{+// 5: XX日XX月XXXX年*/ }
    byDispWeek: BYTE;
{= 是否显示星期 }
    byOSDAttrib: BYTE;
{= OSD属性:透明，闪烁 }
{+// 0: 不显示OSD*/ }
{+// 1: 透明,闪烁*/ }
{+// 2: 透明,不闪烁*/ }
{+// 3: 闪烁,不透明*/ }
{+// 4: 不透明,不闪烁*/ }
    byHourOSDType: BYTE;
{= OSD小时制:0-24小时制,1-12小时制 }
    byRes: array[0..64 - 1] of BYTE;
  end {NET_DVR_PICCFG_V30};
  LPNET_DVR_PICCFG_V30 = ^NET_DVR_PICCFG_V30;

{///通道图象结构SDK_V14扩展 }
type
  NET_DVR_PICCFG_EX = record
    dwSize: LongInt;
    sChanName: array[0..NAME_LEN - 1] of BYTE;
    dwVideoFormat: LongInt;
{= 只读 视频制式 1-NTSC 2-PAL }
    byBrightness: BYTE;
{=亮度,0-255 }
    byContrast: BYTE;
{=对比度,0-255 }
    bySaturation: BYTE;
{=饱和度,0-255 }
    byHue: BYTE;
{=色调,0-255 }
{///显示通道名 }
    dwShowChanName: LongInt;
    wShowNameTopLeftX: Word;
{= 通道名称显示位置的x坐标 }
    wShowNameTopLeftY: Word;
{= 通道名称显示位置的y坐标 }
{///信号丢失报警 }
    struVILost: NET_DVR_VILOST;
{///移动侦测 }
    struMotion: NET_DVR_MOTION;
{///遮挡报警 }
    struHideAlarm: NET_DVR_HIDEALARM;
{///遮挡 区域大小704*576 }
    dwEnableHide: LongInt;
{= 是否启动遮挡 ,0-否,1-是 }
    struShelter: array[0..MAX_SHELTERNUM - 1] of NET_DVR_SHELTER;
{///OSD }
    dwShowOsd: LongInt;
    wOSDTopLeftX: Word;
{= OSD的x坐标 }
    wOSDTopLeftY: Word;
{= OSD的y坐标 }
    byOSDType: BYTE;
{= OSD类型(主要是年月日格式) }
{+// 0: XXXX-XX-XX 年月日*/ }
{+// 1: XX-XX-XXXX 月日年*/ }
{+// 2: XXXX年XX月XX日*/ }
{+// 3: XX月XX日XXXX年*/ }
{+// 4: XX-XX-XXXX 日月年*/ }
{+// 5: XX日XX月XXXX年*/ }
    byDispWeek: BYTE;
{= 是否显示星期 }
    byOSDAttrib: BYTE;
{= OSD属性:透明，闪烁 }
{+// 0: 不显示OSD*/ }
{+// 1: 透明,闪烁*/ }
{+// 2: 透明,不闪烁*/ }
{+// 3: 闪烁,不透明*/ }
{+// 4: 不透明,不闪烁*/ }
    byHourOsdType: BYTE;
  end {NET_DVR_PICCFG_EX};
  LPNET_DVR_PICCFG_EX = ^NET_DVR_PICCFG_EX;

{///通道图象结构(SDK_V13及之前版本) }
type
  NET_DVR_PICCFG = record
    dwSize: LongInt;
    sChanName: array[0..NAME_LEN - 1] of BYTE;
    dwVideoFormat: LongInt;
{= 只读 视频制式 1-NTSC 2-PAL }
    byBrightness: BYTE;
{=亮度,0-255 }
    byContrast: BYTE;
{=对比度,0-255 }
    bySaturation: BYTE;
{=饱和度,0-255 }
    byHue: BYTE;
{=色调,0-255 }
{///显示通道名 }
    dwShowChanName: LongInt;
    wShowNameTopLeftX: Word;
{= 通道名称显示位置的x坐标 }
    wShowNameTopLeftY: Word;
{= 通道名称显示位置的y坐标 }
{///信号丢失报警 }
    struVILost: NET_DVR_VILOST;
{///移动侦测 }
    struMotion: NET_DVR_MOTION;
{///遮挡报警 }
    struHideAlarm: NET_DVR_HIDEALARM;
{///遮挡 区域大小704*576 }
    dwEnableHide: LongInt;
{= 是否启动遮挡 ,0-否,1-是 }
    wHideAreaTopLeftX: Word;
{= 遮挡区域的x坐标 }
    wHideAreaTopLeftY: Word;
{= 遮挡区域的y坐标 }
    wHideAreaWidth: Word;
{= 遮挡区域的宽 }
    wHideAreaHeight: Word;
{=遮挡区域的高 }
{///OSD }
    dwShowOsd: LongInt;
    wOSDTopLeftX: Word;
{= OSD的x坐标 }
    wOSDTopLeftY: Word;
{= OSD的y坐标 }
    byOSDType: BYTE;
{= OSD类型(主要是年月日格式) }
{+// 0: XXXX-XX-XX 年月日*/ }
{+// 1: XX-XX-XXXX 月日年*/ }
{+// 2: XXXX年XX月XX日*/ }
{+// 3: XX月XX日XXXX年*/ }
{+// 4: XX-XX-XXXX 日月年*/ }
{+// 5: XX日XX月XXXX年*/ }
    byDispWeek: BYTE;
{= 是否显示星期 }
    byOSDAttrib: BYTE;
{= OSD属性:透明，闪烁 }
{+// 0: 不显示OSD*/ }
{+// 1: 透明,闪烁*/ }
{+// 2: 透明,不闪烁*/ }
{+// 3: 闪烁,不透明*/ }
{+// 4: 不透明,不闪烁*/ }
    reservedData2: Char;
  end {NET_DVR_PICCFG};
  LPNET_DVR_PICCFG = ^NET_DVR_PICCFG;

{///码流压缩参数(子结构)(9000扩展) }
type
  NET_DVR_COMPRESSION_INFO_V30 = record
    byStreamType: BYTE;
    byResolution: BYTE;
    byBitrateType: BYTE;
    byPicQuality: BYTE;
    dwVideoBitrate: LongInt;
{/// 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K }
{///最高位(31位)置成1表示是自定义码流, 0-30位表示码流值。 }
    dwVideoFrameRate: LongInt;
    wIntervalFrameI: Word;
{///2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题 }
    byIntervalBPFrame: BYTE;
    byres1: BYTE;
    byVideoEncType: BYTE;
    byAudioEncType: BYTE;
    byres: array[0..10 - 1] of BYTE;
  end {NET_DVR_COMPRESSION_INFO_V30};
  LPNET_DVR_COMPRESSION_INFO_V30 = ^NET_DVR_COMPRESSION_INFO_V30;

{///通道压缩参数(9000扩展) }
type
  NET_DVR_COMPRESSIONCFG_V30 = record
    dwSize: LongInt;
    struNormHighRecordPara: NET_DVR_COMPRESSION_INFO_V30;
    struNormLowRecordPara: NET_DVR_COMPRESSION_INFO_V30;
    struEventRecordPara: NET_DVR_COMPRESSION_INFO_V30;
    struNetPara: NET_DVR_COMPRESSION_INFO_V30;
  end {NET_DVR_COMPRESSIONCFG_V30};
  LPNET_DVR_COMPRESSIONCFG_V30 = ^NET_DVR_COMPRESSIONCFG_V30;

{///码流压缩参数(子结构) }
type
  NET_DVR_COMPRESSION_INFO = record
    byStreamType: BYTE;
    byResolution: BYTE;
    byBitrateType: BYTE;
    byPicQuality: BYTE;
    dwVideoBitrate: LongInt;
{/// 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K }
{///最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。 }
    dwVideoFrameRate: LongInt;
  end {NET_DVR_COMPRESSION_INFO};
  LPNET_DVR_COMPRESSION_INFO = ^NET_DVR_COMPRESSION_INFO;

{///通道压缩参数 }
type
  NET_DVR_COMPRESSIONCFG = record
    dwSize: LongInt;
    struRecordPara: NET_DVR_COMPRESSION_INFO;
    struNetPara: NET_DVR_COMPRESSION_INFO;
  end {NET_DVR_COMPRESSIONCFG};
  LPNET_DVR_COMPRESSIONCFG = ^NET_DVR_COMPRESSIONCFG;

{///码流压缩参数(子结构)(扩展) 增加I帧间隔 }
type
  NET_DVR_COMPRESSION_INFO_EX = record
    byStreamType: BYTE;
    byResolution: BYTE;
    byBitrateType: BYTE;
    byPicQuality: BYTE;
    dwVideoBitrate: LongInt;
{/// 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K }
{///最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。 }
    dwVideoFrameRate: LongInt;
    wIntervalFrameI: Word;
{///2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题 }
    byIntervalBPFrame: BYTE;
    byRes: BYTE;
  end {NET_DVR_COMPRESSION_INFO_EX};
  LPNET_DVR_COMPRESSION_INFO_EX = ^NET_DVR_COMPRESSION_INFO_EX;

{///通道压缩参数(扩展) }
type
  NET_DVR_COMPRESSIONCFG_EX = record
    dwSize: LongInt;
    struRecordPara: NET_DVR_COMPRESSION_INFO_EX;
    struNetPara: NET_DVR_COMPRESSION_INFO_EX;
  end {NET_DVR_COMPRESSIONCFG_EX};
  LPNET_DVR_COMPRESSIONCFG_EX = ^NET_DVR_COMPRESSIONCFG_EX;


{///时间段录像参数配置(子结构) }
type
  NET_DVR_RECORDSCHED = record
    struRecordTime: NET_DVR_SCHEDTIME;
    byRecordType: BYTE;
    reservedData: array[0..3 - 1] of Char;
  end {NET_DVR_RECORDSCHED};
  LPNET_DVR_RECORDSCHED = ^NET_DVR_RECORDSCHED;

{///全天录像参数配置(子结构) }
type
  NET_DVR_RECORDDAY = record
    wAllDayRecord: Word;
{= 是否全天录像 0-否 1-是 }
    byRecordType: BYTE;
{= 录象类型 0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 6: 手动录像 }
    reservedData: Char;
  end {NET_DVR_RECORDDAY};
  LPNET_DVR_RECORDDAY = ^NET_DVR_RECORDDAY;

{///通道录像参数配置(9000扩展) }
type
  NET_DVR_RECORD_V30 = record
    dwSize: LongInt;
    dwRecord: LongInt;
{=是否录像 0-否 1-是 }
    struRecAllDay: array[0..MAX_DAYS - 1] of NET_DVR_RECORDDAY;
    struRecordSched: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT_V30 - 1] of NET_DVR_RECORDSCHED;
    dwRecordTime: LongInt;
{= 录象延时长度 0-5秒， 1-20秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟 }
    dwPreRecordTime: LongInt;
{= 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) }
    dwRecorderDuration: LongInt;
{= 录像保存的最长时间 }
    byRedundancyRec: BYTE;
{=是否冗余录像,重要数据双备份：0/1 }
    byAudioRec: BYTE;
{=录像时复合流编码时是否记录音频数据：国外有此法规 }
    byReserve: array[0..10 - 1] of BYTE;
  end {NET_DVR_RECORD_V30};
  LPNET_DVR_RECORD_V30 = ^NET_DVR_RECORD_V30;

{///通道录像参数配置 }
type
  NET_DVR_RECORD = record
    dwSize: LongInt;
    dwRecord: LongInt;
{=是否录像 0-否 1-是 }
    struRecAllDay: array[0..MAX_DAYS - 1] of NET_DVR_RECORDDAY;
    struRecordSched: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT - 1] of NET_DVR_RECORDSCHED;
    dwRecordTime: LongInt;
{= 录象时间长度 }
    dwPreRecordTime: LongInt;
{= 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) }
  end {NET_DVR_RECORD};
  LPNET_DVR_RECORD = ^NET_DVR_RECORD;

{///云台协议表结构配置 }
type
  NET_DVR_PTZ_PROTOCOL = record
    dwType: LongInt;
{=解码器类型值，从1开始连续递增 }
    byDescribe: array[0..DESC_LEN - 1] of BYTE;
{=解码器的描述符，和8000中的一致 }
  end {NET_DVR_PTZ_PROTOCOL};

type
  NET_DVR_PTZCFG = record
    dwSize: LongInt;
    struPtz: array[0..PTZ_PROTOCOL_NUM - 1] of NET_DVR_PTZ_PROTOCOL;
{=最大200中PTZ协议 }
    dwPtzNum: LongInt;
{=有效的ptz协议数目，从0开始(即计算时加1) }
    byRes: array[0..8 - 1] of BYTE;
  end {NET_DVR_PTZCFG};
  LPNET_DVR_PTZCFG = ^NET_DVR_PTZCFG;
{+//**************************云台类型(end)******************************/ }

{///通道解码器(云台)参数配置(9000扩展) }
type
  NET_DVR_DECODERCFG_V30 = record
    dwSize: LongInt;
    dwBaudRate: LongInt;
    byDataBit: BYTE;
    byStopBit: BYTE;
    byParity: BYTE;
    byFlowcontrol: BYTE;
    wDecoderType: Word;
    wDecoderAddress: Word;
{=解码器地址:0 - 255 }
    bySetPreset: array[0..MAX_PRESET_V30 - 1] of BYTE;
{= 预置点是否设置,0-没有设置,1-设置 }
    bySetCruise: array[0..MAX_CRUISE_V30 - 1] of BYTE;
{= 巡航是否设置: 0-没有设置,1-设置 }
    bySetTrack: array[0..MAX_TRACK_V30 - 1] of BYTE;
{= 轨迹是否设置,0-没有设置,1-设置 }
  end {NET_DVR_DECODERCFG_V30};
  LPNET_DVR_DECODERCFG_V30 = ^NET_DVR_DECODERCFG_V30;

{///通道解码器(云台)参数配置 }
type
  NET_DVR_DECODERCFG = record
    dwSize: LongInt;
    dwBaudRate: LongInt;
    byDataBit: BYTE;
    byStopBit: BYTE;
    byParity: BYTE;
    byFlowcontrol: BYTE;
    wDecoderType: Word;
    wDecoderAddress: Word;
{=解码器地址:0 - 255 }
    bySetPreset: array[0..MAX_PRESET - 1] of BYTE;
{= 预置点是否设置,0-没有设置,1-设置 }
    bySetCruise: array[0..MAX_CRUISE - 1] of BYTE;
{= 巡航是否设置: 0-没有设置,1-设置 }
    bySetTrack: array[0..MAX_TRACK - 1] of BYTE;
{= 轨迹是否设置,0-没有设置,1-设置 }
  end {NET_DVR_DECODERCFG};
  LPNET_DVR_DECODERCFG = ^NET_DVR_DECODERCFG;

{///ppp参数配置(子结构) }
type
  NET_DVR_PPPCFG_V30 = record
    struRemoteIP: NET_DVR_IPADDR;
    struLocalIP: NET_DVR_IPADDR;
    sLocalIPMask: array[0..16 - 1] of Char;
    sUsername: array[0..NAME_LEN - 1] of BYTE;
{= 用户名 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
{= 密码 }
    byPPPMode: BYTE;
    byRedial: BYTE;
    byRedialMode: BYTE;
    byDataEncrypt: BYTE;
    dwMTU: LongInt;
    sTelephoneNumber: array[0..PHONENUMBER_LEN - 1] of Char;
  end {NET_DVR_PPPCFG_V30};
  LPNET_DVR_PPPCFG_V30 = ^NET_DVR_PPPCFG_V30;

{///ppp参数配置(子结构) }
type
  NET_DVR_PPPCFG = record
    sRemoteIP: array[0..16 - 1] of Char;
    sLocalIP: array[0..16 - 1] of Char;
    sLocalIPMask: array[0..16 - 1] of Char;
    sUsername: array[0..NAME_LEN - 1] of BYTE;
{= 用户名 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
{= 密码 }
    byPPPMode: BYTE;
    byRedial: BYTE;
    byRedialMode: BYTE;
    byDataEncrypt: BYTE;
    dwMTU: LongInt;
    sTelephoneNumber: array[0..PHONENUMBER_LEN - 1] of Char;
  end {NET_DVR_PPPCFG};
  LPNET_DVR_PPPCFG = ^NET_DVR_PPPCFG;

{///RS232串口参数配置(9000扩展) }
type
  NET_DVR_SINGLE_RS232 = record
    dwBaudRate: LongInt;
{=波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k; }
    byDataBit: BYTE;
{= 数据有几位 0－5位，1－6位，2－7位，3－8位 }
    byStopBit: BYTE;
{= 停止位 0－1位，1－2位 }
    byParity: BYTE;
{= 校验 0－无校验，1－奇校验，2－偶校验 }
    byFlowcontrol: BYTE;
{= 0－无，1－软流控,2-硬流控 }
    dwWorkMode: LongInt;
{= 工作模式，0－232串口用于PPP拨号，1－232串口用于参数控制，2－透明通道 }
  end {NET_DVR_SINGLE_RS232};

{///RS232串口参数配置(9000扩展) }
type
  NET_DVR_RS232CFG_V30 = record
    dwSize: LongInt;
    struRs232: NET_DVR_SINGLE_RS232;
    byRes: array[0..84 - 1] of BYTE;
    struPPPConfig: NET_DVR_PPPCFG_V30;
  end {NET_DVR_RS232CFG_V30};
  LPNET_DVR_RS232CFG_V30 = ^NET_DVR_RS232CFG_V30;

{///RS232串口参数配置 }
type
  NET_DVR_RS232CFG = record
    dwSize: LongInt;
    dwBaudRate: LongInt;
    byDataBit: BYTE;
    byStopBit: BYTE;
    byParity: BYTE;
    byFlowcontrol: BYTE;
    dwWorkMode: LongInt;
    struPPPConfig: NET_DVR_PPPCFG;
  end {NET_DVR_RS232CFG};
  LPNET_DVR_RS232CFG = ^NET_DVR_RS232CFG;

{///报警输入参数配置(9000扩展) }
type
  NET_DVR_ALARMINCFG_V30 = record
    dwSize: LongInt;
    sAlarmInName: array[0..NAME_LEN - 1] of BYTE;
{= 名称 }
    byAlarmType: BYTE;
    byAlarmInHandle: BYTE;
{= 是否处理 0-不处理 1-处理 }
    byRes1: array[0..2 - 1] of BYTE;
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;
{= 处理方式 }
    struAlarmTime: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT_V30 - 1] of NET_DVR_SCHEDTIME;
    byRelRecordChan: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
    byEnablePreset: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 是否调用预置点 0-否,1-是 }
    byPresetNo: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。 }
    byRes2: array[0..192 - 1] of BYTE;
{=保留 }
    byEnableCruise: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 是否调用巡航 0-否,1-是 }
    byCruiseNo: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 巡航 }
    byEnablePtzTrack: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 是否调用轨迹 0-否,1-是 }
    byPTZTrack: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 调用的云台的轨迹序号 }
    byRes3: array[0..16 - 1] of BYTE;
  end {NET_DVR_ALARMINCFG_V30};
  LPNET_DVR_ALARMINCFG_V30 = ^NET_DVR_ALARMINCFG_V30;

{///报警输入参数配置 }
type
  NET_DVR_ALARMINCFG = record
    dwSize: LongInt;
    sAlarmInName: array[0..NAME_LEN - 1] of BYTE;
{= 名称 }
    byAlarmType: BYTE;
    byAlarmInHandle: BYTE;
{= 是否处理 0-不处理 1-处理 }
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION;
{= 处理方式 }
    struAlarmTime: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT - 1] of NET_DVR_SCHEDTIME;
    byRelRecordChan: array[0..MAX_CHANNUM - 1] of BYTE;
    byEnablePreset: array[0..MAX_CHANNUM - 1] of BYTE;
{= 是否调用预置点 0-否,1-是 }
    byPresetNo: array[0..MAX_CHANNUM - 1] of BYTE;
{= 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。 }
    byEnableCruise: array[0..MAX_CHANNUM - 1] of BYTE;
{= 是否调用巡航 0-否,1-是 }
    byCruiseNo: array[0..MAX_CHANNUM - 1] of BYTE;
{= 巡航 }
    byEnablePtzTrack: array[0..MAX_CHANNUM - 1] of BYTE;
{= 是否调用轨迹 0-否,1-是 }
    byPTZTrack: array[0..MAX_CHANNUM - 1] of BYTE;
{= 调用的云台的轨迹序号 }
  end {NET_DVR_ALARMINCFG};
  LPNET_DVR_ALARMINCFG = ^NET_DVR_ALARMINCFG;


{///上传报警信息(9000扩展) }
type
  NET_DVR_ALARMINFO_V30 = record
    dwAlarmType: LongInt;
{=0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 0xa-GPS定位信息(车载定制) }
    dwAlarmInputNumber: LongInt;
{=报警输入端口 }
    byAlarmOutputNumber: array[0..MAX_ALARMOUT_V30 - 1] of BYTE;
{=触发的输出端口，为1表示对应输出 }
    byAlarmRelateChannel: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{=触发的录像通道，为1表示对应录像, dwAlarmRelateChannel[0]对应第1个通道 }
    byChannel: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{=dwAlarmType为2或3,6时，表示哪个通道，dwChannel[0]对应第1个通道 }
    byDiskNumber: array[0..MAX_DISKNUM_V30 - 1] of BYTE;
{=dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]对应第1个硬盘 }
  end {NET_DVR_ALARMINFO_V30};
  LPNET_DVR_ALARMINFO_V30 = ^NET_DVR_ALARMINFO_V30;

type
  NET_DVR_ALARMINFO = record
    dwAlarmType: LongInt;
{=0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-串口状态, 0xa-GPS定位信息(车载定制) }
    dwAlarmInputNumber: LongInt;
{=报警输入端口, 当报警类型为9时该变量表示串口状态0表示正常， -1表示错误 }
    dwAlarmOutputNumber: array[0..MAX_ALARMOUT - 1] of LongInt;
{=触发的输出端口，哪一位为1表示对应哪一个输出 }
    dwAlarmRelateChannel: array[0..MAX_CHANNUM - 1] of LongInt;
{=触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道 }
    dwChannel: array[0..MAX_CHANNUM - 1] of LongInt;
{=dwAlarmType为2或3,6时，表示哪个通道，dwChannel[0]位对应第1个通道 }
    dwDiskNumber: array[0..MAX_DISKNUM - 1] of LongInt;
{=dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘 }
  end {NET_DVR_ALARMINFO};
  LPNET_DVR_ALARMINFO = ^NET_DVR_ALARMINFO;




{/////////////////////////////////////////////////////////////////////////////////////// }
{///IPC接入参数配置 }
{+// IP设备结构*/ }
type
  NET_DVR_IPDEVINFO = record
    dwEnable: LongInt;
{= 该IP设备是否启用 }
    sUserName: array[0..NAME_LEN - 1] of BYTE;
{= 用户名 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
{= 密码 }
    struIP: NET_DVR_IPADDR;
{= IP地址 }
    wDVRPort: Word;
{= 端口号 }
    byRes: array[0..34 - 1] of BYTE;
{= 保留 }
  end {NET_DVR_IPDEVINFO};
  LPNET_DVR_IPDEVINFO = ^NET_DVR_IPDEVINFO;

{+// IP通道匹配参数*/ }
type
  NET_DVR_IPCHANINFO = record
    byEnable: BYTE;
{= 0表示9000设备的数字通道连接对应的IPC或DVS失败，该通道不在线；1表示连接成功，该通道在线； }
    byIPID: BYTE;
{= IP设备ID 取值1- MAX_IP_DEVICE }
    byChannel: BYTE;
{= 通道号 }
    byRes: array[0..33 - 1] of BYTE;
{= 保留 }
  end {NET_DVR_IPCHANINFO};
  LPNET_DVR_IPCHANINFO = ^NET_DVR_IPCHANINFO;

{+// IP接入配置结构*/ }
type
  NET_DVR_IPPARACFG = record
    dwSize: LongInt;
{= 结构大小 }
    struIPDevInfo: array[0..MAX_IP_DEVICE - 1] of NET_DVR_IPDEVINFO;
{= IP设备 }
    byAnalogChanEnable: array[0..MAX_ANALOG_CHANNUM - 1] of BYTE;
{= 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效 }
    struIPChanInfo: array[0..MAX_IP_CHANNEL - 1] of NET_DVR_IPCHANINFO;
{= IP通道 }
  end {NET_DVR_IPPARACFG};
  LPNET_DVR_IPPARACFG = ^NET_DVR_IPPARACFG;

{+// 报警输出参数*/ }
type
  NET_DVR_IPALARMOUTINFO = record
    byIPID: BYTE;
{= IP设备ID取值1- MAX_IP_DEVICE }
    byAlarmOut: BYTE;
{= 报警输出号 }
    byRes: array[0..18 - 1] of BYTE;
{= 保留 }
  end {NET_DVR_IPALARMOUTINFO};
  LPNET_DVR_IPALARMOUTINFO = ^NET_DVR_IPALARMOUTINFO;

{+// IP报警输出配置结构*/ }
type
  NET_DVR_IPALARMOUTCFG = record
    dwSize: LongInt;
{= 结构大小 }
    struIPAlarmOutInfo: array[0..MAX_IP_ALARMOUT - 1] of NET_DVR_IPALARMOUTINFO;
{= IP报警输出 }
  end {NET_DVR_IPALARMOUTCFG};
  LPNET_DVR_IPALARMOUTCFG = ^NET_DVR_IPALARMOUTCFG;

{+// 报警输入参数*/ }
type
  NET_DVR_IPALARMININFO = record
    byIPID: BYTE;
{= IP设备ID取值1- MAX_IP_DEVICE }
    byAlarmIn: BYTE;
{= 报警输入号 }
    byRes: array[0..18 - 1] of BYTE;
{= 保留 }
  end {NET_DVR_IPALARMININFO};
  LPNET_DVR_IPALARMININFO = ^NET_DVR_IPALARMININFO;

{+// IP报警输入配置结构*/ }
type
  NET_DVR_IPALARMINCFG = record
    dwSize: LongInt;
{= 结构大小 }
    struIPAlarmInInfo: array[0..MAX_IP_ALARMIN - 1] of NET_DVR_IPALARMININFO;
{= IP报警输入 }
  end {NET_DVR_IPALARMINCFG};
  LPNET_DVR_IPALARMINCFG = ^NET_DVR_IPALARMINCFG;

{///ipc alarm info }
type
  NET_DVR_IPALARMINFO = record
    struIPDevInfo: array[0..MAX_IP_DEVICE - 1] of NET_DVR_IPDEVINFO;
{= IP设备 }
    byAnalogChanEnable: array[0..MAX_ANALOG_CHANNUM - 1] of BYTE;
{= 模拟通道是否启用，0-未启用 1-启用 }
    struIPChanInfo: array[0..MAX_IP_CHANNEL - 1] of NET_DVR_IPCHANINFO;
{= IP通道 }
    struIPAlarmInInfo: array[0..MAX_IP_ALARMIN - 1] of NET_DVR_IPALARMININFO;
{= IP报警输入 }
    struIPAlarmOutInfo: array[0..MAX_IP_ALARMOUT - 1] of NET_DVR_IPALARMOUTINFO;
{= IP报警输出 }
  end {NET_DVR_IPALARMINFO};
  LPNET_DVR_IPALARMINFO = ^NET_DVR_IPALARMINFO;
{///本地硬盘信息配置 }
type
  NET_DVR_SINGLE_HD = record
    dwHDNo: LongInt;
{=硬盘号, 取值0~MAX_DISKNUM_V30-1 }
    dwCapacity: LongInt;
{=硬盘容量(不可设置) }
    dwFreeSpace: LongInt;
{=硬盘剩余空间(不可设置) }
    dwHdStatus: LongInt;
{=硬盘状态(不可设置) 0-正常, 1-未格式化, 2-错误, 3-SMART状态, 4-不匹配, 5-休眠 }
    byHDAttr: BYTE;
{=0-默认, 1-冗余; 2-只读 }
    byRes1: array[0..3 - 1] of BYTE;
    dwHdGroup: LongInt;
{=属于哪个盘组 1-MAX_HD_GROUP }
    byRes2: array[0..120 - 1] of BYTE;
  end {NET_DVR_SINGLE_HD};
  LPNET_DVR_SINGLE_HD = ^NET_DVR_SINGLE_HD;

type
  NET_DVR_HDCFG = record
    dwSize: LongInt;
    dwHDCount: LongInt;
{=硬盘数(不可设置) }
    struHDInfo: array[0..MAX_DISKNUM_V30 - 1] of NET_DVR_SINGLE_HD;
  end {NET_DVR_HDCFG};
  LPNET_DVR_HDCFG = ^NET_DVR_HDCFG;

{///本地盘组信息配置 }
type
  NET_DVR_SINGLE_HDGROUP = record
    dwHDGroupNo: LongInt;
{=盘组号(不可设置) 1-MAX_HD_GROUP }
    byHDGroupChans: array[0..64 - 1] of BYTE;
{=盘组对应的录像通道, 0-表示该通道不录象到该盘组，1-表示录象到该盘组 }
    byRes: array[0..8 - 1] of BYTE;
  end {NET_DVR_SINGLE_HDGROUP};
  LPNET_DVR_SINGLE_HDGROUP = ^NET_DVR_SINGLE_HDGROUP;

type
  NET_DVR_HDGROUP_CFG = record
    dwSize: LongInt;
    dwHDGroupCount: LongInt;
{=盘组总数(不可设置) }
    struHDGroupAttr: array[0..MAX_HD_GROUP - 1] of NET_DVR_SINGLE_HDGROUP;
  end {NET_DVR_HDGROUP_CFG};
  LPNET_DVR_HDGROUP_CFG = ^NET_DVR_HDGROUP_CFG;


{///配置缩放参数的结构 }
type
  NET_DVR_SCALECFG = record
    dwSize: LongInt;
    dwMajorScale: LongInt;
{= 主显示 0-不缩放，1-缩放 }
    dwMinorScale: LongInt;
{= 辅显示 0-不缩放，1-缩放 }
    dwRes: array[0..2 - 1] of LongInt;
  end {NET_DVR_SCALECFG};
  LPNET_DVR_SCALECFG = ^NET_DVR_SCALECFG;



{///DVR报警输出(9000扩展) }
type
  NET_DVR_ALARMOUTCFG_V30 = record
    dwSize: LongInt;
    sAlarmOutName: array[0..NAME_LEN - 1] of BYTE;
{= 名称 }
    dwAlarmOutDelay: LongInt;
{= 输出保持时间(-1为无限，手动关闭) }
{///0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动 }
    struAlarmOutTime: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT_V30 - 1] of NET_DVR_SCHEDTIME;
{= 报警输出激活时间段 }
    byRes: array[0..16 - 1] of BYTE;
  end {NET_DVR_ALARMOUTCFG_V30};
  LPNET_DVR_ALARMOUTCFG_V30 = ^NET_DVR_ALARMOUTCFG_V30;

{///DVR报警输出 }
type
  NET_DVR_ALARMOUTCFG = record
    dwSize: LongInt;
    sAlarmOutName: array[0..NAME_LEN - 1] of BYTE;
{= 名称 }
    dwAlarmOutDelay: LongInt;
{= 输出保持时间(-1为无限，手动关闭) }
{///0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动 }
    struAlarmOutTime: array[0..MAX_DAYS - 1, 0..MAX_TIMESEGMENT - 1] of NET_DVR_SCHEDTIME;
{= 报警输出激活时间段 }
  end {NET_DVR_ALARMOUTCFG};
  LPNET_DVR_ALARMOUTCFG = ^NET_DVR_ALARMOUTCFG;

{///DVR本地预览参数(9000扩展) }
type
  NET_DVR_PREVIEWCFG_V30 = record
    dwSize: LongInt;
    byPreviewNumber: BYTE;
    byEnableAudio: BYTE;
    wSwitchTime: Word;
    bySwitchSeq: array[0..MAX_PREVIEW_MODE - 1, 0..MAX_WINDOW_V30 - 1] of BYTE;
    byRes: array[0..24 - 1] of BYTE;
  end {NET_DVR_PREVIEWCFG_V30};
  LPNET_DVR_PREVIEWCFG_V30 = ^NET_DVR_PREVIEWCFG_V30;
{///DVR本地预览参数 }
type
  NET_DVR_PREVIEWCFG = record
    dwSize: LongInt;
    byPreviewNumber: BYTE;
    byEnableAudio: BYTE;
    wSwitchTime: Word;
    bySwitchSeq: array[0..MAX_WINDOW - 1] of BYTE;
  end {NET_DVR_PREVIEWCFG};
  LPNET_DVR_PREVIEWCFG = ^NET_DVR_PREVIEWCFG;

{///DVR视频输出 }
type
  NET_DVR_VGAPARA = record
    wResolution: Word;
{= 分辨率 }
    wFreq: Word;
{= 刷新频率 }
    dwBrightness: LongInt;
{= 亮度 }
  end {NET_DVR_VGAPARA};

{+// }
{-* MATRIX输出参数结构 }
{= }
type
  NET_DVR_MATRIXPARA_V30 = record
    wOrder: array[0..MAX_ANALOG_CHANNUM - 1] of Word;
{= 预览顺序, 0xff表示相应的窗口不预览 }
    wSwitchTime: Word;
{= 预览切换时间 }
    res: array[0..14 - 1] of BYTE;
  end {NET_DVR_MATRIXPARA_V30};
  LPNET_DVR_MATRIXPARA_V30 = ^NET_DVR_MATRIXPARA_V30;

type
  NET_DVR_MATRIXPARA = record
    wDisplayLogo: Word;
{= 显示视频通道号 }
    wDisplayOsd: Word;
{= 显示时间 }
  end {NET_DVR_MATRIXPARA};

type
  NET_DVR_VOOUT = record
    byVideoFormat: BYTE;
{= 输出制式,0-PAL,1-NTSC }
    byMenuAlphaValue: BYTE;
{= 菜单与背景图象对比度 }
    wScreenSaveTime: Word;
{= 屏幕保护时间 0-从不,1-1分钟,2-2分钟,3-5分钟,4-10分钟,5-20分钟,6-30分钟 }
    wVOffset: Word;
{= 视频输出偏移 }
    wBrightness: Word;
{= 视频输出亮度 }
    byStartMode: BYTE;
{= 启动后视频输出模式(0:菜单,1:预览) }
    byEnableScaler: BYTE;
{= 是否启动缩放 (0-不启动, 1-启动) }
  end {NET_DVR_VOOUT};

{///DVR视频输出(9000扩展) }
type
  NET_DVR_VIDEOOUT_V30 = record
    dwSize: LongInt;
    struVOOut: array[0..MAX_VIDEOOUT_V30 - 1] of NET_DVR_VOOUT;
    struVGAPara: array[0..MAX_VGA_V30 - 1] of NET_DVR_VGAPARA;
{= VGA参数 }
    struMatrixPara: array[0..MAX_MATRIXOUT - 1] of NET_DVR_MATRIXPARA_V30;
{= MATRIX参数 }
    byRes: array[0..16 - 1] of BYTE;
  end {NET_DVR_VIDEOOUT_V30};
  LPNET_DVR_VIDEOOUT_V30 = ^NET_DVR_VIDEOOUT_V30;

{///DVR视频输出 }
type
  NET_DVR_VIDEOOUT = record
    dwSize: LongInt;
    struVOOut: array[0..MAX_VIDEOOUT - 1] of NET_DVR_VOOUT;
    struVGAPara: array[0..MAX_VGA - 1] of NET_DVR_VGAPARA;
{= VGA参数 }
    struMatrixPara: NET_DVR_MATRIXPARA;
{= MATRIX参数 }
  end {NET_DVR_VIDEOOUT};
  LPNET_DVR_VIDEOOUT = ^NET_DVR_VIDEOOUT;

{///单用户参数(子结构)(9000扩展) }
type
  NET_DVR_USER_INFO_V30 = record
    sUserName: array[0..NAME_LEN - 1] of BYTE;
{= 用户名 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
{= 密码 }
    byLocalRight: array[0..MAX_RIGHT - 1] of BYTE;
{= 本地权限 }
{+//数组0: 本地控制云台*/ }
{+//数组1: 本地手动录象*/ }
{+//数组2: 本地回放*/ }
{+//数组3: 本地设置参数*/ }
{+//数组4: 本地查看状态、日志*/ }
{+//数组5: 本地高级操作(升级，格式化，重启，关机)*/ }
{+//数组6: 本地查看参数*/ }
{+//数组7: 本地管理模拟和IP camera*/ }
{+//数组8: 本地备份*/ }
{+//数组9: 本地关机/重启*/ }
    byRemoteRight: array[0..MAX_RIGHT - 1] of BYTE;
{= 远程权限 }
{+//数组0: 远程控制云台*/ }
{+//数组1: 远程手动录象*/ }
{+//数组2: 远程回放*/ }
{+//数组3: 远程设置参数*/ }
{+//数组4: 远程查看状态、日志*/ }
{+//数组5: 远程高级操作(升级，格式化，重启，关机)*/ }
{+//数组6: 远程发起语音对讲*/ }
{+//数组7: 远程预览*/ }
{+//数组8: 远程请求报警上传、报警输出*/ }
{+//数组9: 远程控制，本地输出*/ }
{+//数组10: 远程控制串口*/ }
{+//数组11: 远程查看参数*/ }
{+//数组12: 远程管理模拟和IP camera*/ }
{+//数组13: 远程关机/重启*/ }
    byNetPreviewRight: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 远程可以预览的通道 0-有权限，1-无权限 }
    byLocalPlaybackRight: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 本地可以回放的通道 0-有权限，1-无权限 }
    byNetPlaybackRight: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 远程可以回放的通道 0-有权限，1-无权限 }
    byLocalRecordRight: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 本地可以录像的通道 0-有权限，1-无权限 }
    byNetRecordRight: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 远程可以录像的通道 0-有权限，1-无权限 }
    byLocalPTZRight: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 本地可以PTZ的通道 0-有权限，1-无权限 }
    byNetPTZRight: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 远程可以PTZ的通道 0-有权限，1-无权限 }
    byLocalBackupRight: array[0..MAX_CHANNUM_V30 - 1] of BYTE;
{= 本地备份权限通道 0-有权限，1-无权限 }
    struUserIP: NET_DVR_IPADDR;
{= 用户IP地址(为0时表示允许任何地址) }
    byMACAddr: array[0..MACADDR_LEN - 1] of BYTE;
{= 物理地址 }
    byPriority: BYTE;
{= 优先级，0xff-无，0--低，1--中，2--高 }
{+// }
{-无……表示不支持优先级的设置 }
{-低……默认权限:包括本地和远程回放,本地和远程查看日志和状态,本地和远程关机/重启 }
{-中……包括本地和远程控制云台,本地和远程手动录像,本地和远程回放,语音对讲和远程预览 }
{-本地备份,本地/远程关机/重启 }
{-高……管理员 }
{= }
    byRes: array[0..17 - 1] of BYTE;
  end {NET_DVR_USER_INFO_V30};
  LPNET_DVR_USER_INFO_V30 = ^NET_DVR_USER_INFO_V30;

{///单用户参数(SDK_V15扩展)(子结构) }
type
  NET_DVR_USER_INFO_EX = record
    sUserName: array[0..NAME_LEN - 1] of BYTE;
{= 用户名 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
{= 密码 }
    dwLocalRight: array[0..MAX_RIGHT - 1] of LongInt;
{= 权限 }
{+//数组0: 本地控制云台*/ }
{+//数组1: 本地手动录象*/ }
{+//数组2: 本地回放*/ }
{+//数组3: 本地设置参数*/ }
{+//数组4: 本地查看状态、日志*/ }
{+//数组5: 本地高级操作(升级，格式化，重启，关机)*/ }
    dwLocalPlaybackRight: LongInt;
{= 本地可以回放的通道 bit0 -- channel 1 }
    dwRemoteRight: array[0..MAX_RIGHT - 1] of LongInt;
{= 权限 }
{+//数组0: 远程控制云台*/ }
{+//数组1: 远程手动录象*/ }
{+//数组2: 远程回放*/ }
{+//数组3: 远程设置参数*/ }
{+//数组4: 远程查看状态、日志*/ }
{+//数组5: 远程高级操作(升级，格式化，重启，关机)*/ }
{+//数组6: 远程发起语音对讲*/ }
{+//数组7: 远程预览*/ }
{+//数组8: 远程请求报警上传、报警输出*/ }
{+//数组9: 远程控制，本地输出*/ }
{+//数组10: 远程控制串口*/ }
    dwNetPreviewRight: LongInt;
{= 远程可以预览的通道 bit0 -- channel 1 }
    dwNetPlaybackRight: LongInt;
{= 远程可以回放的通道 bit0 -- channel 1 }
    sUserIP: array[0..16 - 1] of Char;
{= 用户IP地址(为0时表示允许任何地址) }
    byMACAddr: array[0..MACADDR_LEN - 1] of BYTE;
{= 物理地址 }
  end {NET_DVR_USER_INFO_EX};
  LPNET_DVR_USER_INFO_EX = ^NET_DVR_USER_INFO_EX;

{///单用户参数(子结构) }
type
  NET_DVR_USER_INFO = record
    sUserName: array[0..NAME_LEN - 1] of BYTE;
{= 用户名 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
{= 密码 }
    dwLocalRight: array[0..MAX_RIGHT - 1] of LongInt;
{= 权限 }
{+//数组0: 本地控制云台*/ }
{+//数组1: 本地手动录象*/ }
{+//数组2: 本地回放*/ }
{+//数组3: 本地设置参数*/ }
{+//数组4: 本地查看状态、日志*/ }
{+//数组5: 本地高级操作(升级，格式化，重启，关机)*/ }
    dwRemoteRight: array[0..MAX_RIGHT - 1] of LongInt;
{= 权限 }
{+//数组0: 远程控制云台*/ }
{+//数组1: 远程手动录象*/ }
{+//数组2: 远程回放*/ }
{+//数组3: 远程设置参数*/ }
{+//数组4: 远程查看状态、日志*/ }
{+//数组5: 远程高级操作(升级，格式化，重启，关机)*/ }
{+//数组6: 远程发起语音对讲*/ }
{+//数组7: 远程预览*/ }
{+//数组8: 远程请求报警上传、报警输出*/ }
{+//数组9: 远程控制，本地输出*/ }
{+//数组10: 远程控制串口*/ }
    sUserIP: array[0..16 - 1] of Char;
{= 用户IP地址(为0时表示允许任何地址) }
    byMACAddr: array[0..MACADDR_LEN - 1] of BYTE;
{= 物理地址 }
  end {NET_DVR_USER_INFO};
  LPNET_DVR_USER_INFO = ^NET_DVR_USER_INFO;


{///DVR用户参数(9000扩展) }
type
  NET_DVR_USER_V30 = record
    dwSize: LongInt;
    struUser: array[0..MAX_USERNUM_V30 - 1] of NET_DVR_USER_INFO_V30;
  end {NET_DVR_USER_V30};
  LPNET_DVR_USER_V30 = ^NET_DVR_USER_V30;

{///DVR用户参数(SDK_V15扩展) }
type
  NET_DVR_USER_EX = record
    dwSize: LongInt;
    struUser: array[0..MAX_USERNUM - 1] of NET_DVR_USER_INFO_EX;
  end {NET_DVR_USER_EX};
  LPNET_DVR_USER_EX = ^NET_DVR_USER_EX;

{///DVR用户参数 }
type
  NET_DVR_USER = record
    dwSize: LongInt;
    struUser: array[0..MAX_USERNUM - 1] of NET_DVR_USER_INFO;
  end {NET_DVR_USER};
  LPNET_DVR_USER = ^NET_DVR_USER;

{///DVR异常参数(9000扩展) }
type
  NET_DVR_EXCEPTION_V30 = record
    dwSize: LongInt;
    struExceptionHandleType: array[0..MAX_EXCEPTIONNUM_V30 - 1] of NET_DVR_HANDLEEXCEPTION_V30;
{+//数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突,4-非法访问, 5-输入/输出视频制式不匹配, 6-行车超速(车载专用)*/ }
  end {NET_DVR_EXCEPTION_V30};
  LPNET_DVR_EXCEPTION_V30 = ^NET_DVR_EXCEPTION_V30;

{///DVR异常参数 }
type
  NET_DVR_EXCEPTION = record
    dwSize: LongInt;
    struExceptionHandleType: array[0..MAX_EXCEPTIONNUM - 1] of NET_DVR_HANDLEEXCEPTION;
{+//数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突,4-非法访问, 5-输入/输出视频制式不匹配, 6-行车超速(车载专用)*/ }
  end {NET_DVR_EXCEPTION};
  LPNET_DVR_EXCEPTION = ^NET_DVR_EXCEPTION;

{///通道状态(9000扩展) }
type
  NET_DVR_CHANNELSTATE_V30 = record
    byRecordStatic: BYTE;
    bySignalStatic: BYTE;
    byHardwareStatic: BYTE;
    byRes1: BYTE;
    dwBitRate: LongInt;
    dwLinkNum: LongInt;
    struClientIP: array[0..MAX_LINK - 1] of NET_DVR_IPADDR;
    dwIPLinkNum: LongInt;
    byRes: array[0..12 - 1] of BYTE;
  end {NET_DVR_CHANNELSTATE_V30};
  LPNET_DVR_CHANNELSTATE_V30 = ^NET_DVR_CHANNELSTATE_V30;

{///通道状态 }
type
  NET_DVR_CHANNELSTATE = record
    byRecordStatic: BYTE;
    bySignalStatic: BYTE;
    byHardwareStatic: BYTE;
    reservedData: Char;
    dwBitRate: LongInt;
    dwLinkNum: LongInt;
    dwClientIP: array[0..MAX_LINK - 1] of LongInt;
  end {NET_DVR_CHANNELSTATE};
  LPNET_DVR_CHANNELSTATE = ^NET_DVR_CHANNELSTATE;

{///硬盘状态 }
type
  NET_DVR_DISKSTATE = record
    dwVolume: LongInt;
    dwFreeSpace: LongInt;
    dwHardDiskStatic: LongInt;
  end {NET_DVR_DISKSTATE};
  LPNET_DVR_DISKSTATE = ^NET_DVR_DISKSTATE;

{///DVR工作状态(9000扩展) }
type
  NET_DVR_WORKSTATE_V30 = record
    dwDeviceStatic: LongInt;
    struHardDiskStatic: array[0..MAX_DISKNUM_V30 - 1] of NET_DVR_DISKSTATE;
    struChanStatic: array[0..MAX_CHANNUM_V30 - 1] of NET_DVR_CHANNELSTATE_V30;
    byAlarmInStatic: array[0..MAX_ALARMIN_V30 - 1] of BYTE;
    byAlarmOutStatic: array[0..MAX_ALARMOUT_V30 - 1] of BYTE;
    dwLocalDisplay: LongInt;
    byAudioChanStatus: array[0..MAX_AUDIO_V30 - 1] of BYTE;
    byRes: array[0..10 - 1] of BYTE;
  end {NET_DVR_WORKSTATE_V30};
  LPNET_DVR_WORKSTATE_V30 = ^NET_DVR_WORKSTATE_V30;

{///DVR工作状态 }
type
  NET_DVR_WORKSTATE = record
    dwDeviceStatic: LongInt;
    struHardDiskStatic: array[0..MAX_DISKNUM - 1] of NET_DVR_DISKSTATE;
    struChanStatic: array[0..MAX_CHANNUM - 1] of NET_DVR_CHANNELSTATE;
    byAlarmInStatic: array[0..MAX_ALARMIN - 1] of BYTE;
    byAlarmOutStatic: array[0..MAX_ALARMOUT - 1] of BYTE;
    dwLocalDisplay: LongInt;
  end {NET_DVR_WORKSTATE};
  LPNET_DVR_WORKSTATE = ^NET_DVR_WORKSTATE;

{+//***********************DVR日志 begin***************************/ }

{+// 报警*/ }
{///主类型 }
const
  MAJOR_ALARM = $1;
{///次类型 }
const
  MINOR_ALARM_IN = $1; {/* 报警输入*/}
const
  MINOR_ALARM_OUT = $2; {/* 报警输出*/}
const
  MINOR_MOTDET_START = $3; {/* 移动侦测报警开始*/}
const
  MINOR_MOTDET_STOP = $4; {/* 移动侦测报警结束*/}
const
  MINOR_HIDE_ALARM_START = $5; {/* 遮挡报警开始*/}
const
  MINOR_HIDE_ALARM_STOP = $6; {/* 遮挡报警结束*/}

{+// 异常*/ }
{///主类型 }
const
  MAJOR_EXCEPTION = $2;
{///次类型 }
const
  MINOR_VI_LOST = $21; {/* 视频信号丢失*/}
const
  MINOR_ILLEGAL_ACCESS = $22; {/* 非法访问*/}
const
  MINOR_HD_FULL = $23; {/* 硬盘满*/}
const
  MINOR_HD_ERROR = $24; {/* 硬盘错误*/}
const
  MINOR_DCD_LOST = $25; {/* MODEM 掉线(保留不使用)*/}
const
  MINOR_IP_CONFLICT = $26; {/* IP地址冲突*/}
const
  MINOR_NET_BROKEN = $27; {/* 网络断开*/}
const
  MINOR_REC_ERROR = $28; {/* 录像出错*/}
const
  MINOR_IPC_NO_LINK = $29; {/* IPC连接异常*/}
const
  MINOR_VI_EXCEPTION = $2A; {/* 视频输入异常(只针对模拟通道)*/}


{+// 操作*/ }
{///主类型 }
const
  MAJOR_OPERATION = $3;
{///次类型 }
const
  MINOR_START_DVR = $41; {/* 开机*/}
const
  MINOR_STOP_DVR = $42; {/* 关机*/}
const
  MINOR_STOP_ABNORMAL = $43; {/* 异常关机*/}
const
  MINOR_REBOOT_DVR = $44; {/*本地重启设备*/}

const
  MINOR_LOCAL_LOGIN = $50; {/* 本地登陆*/}
const
  MINOR_LOCAL_LOGOUT = $51; {/* 本地注销登陆*/}
const
  MINOR_LOCAL_CFG_PARM = $52; {/* 本地配置参数*/}
const
  MINOR_LOCAL_PLAYBYFILE = $53; {/* 本地按文件回放或下载*/}
const
  MINOR_LOCAL_PLAYBYTIME = $54; {/* 本地按时间回放或下载*/}
const
  MINOR_LOCAL_START_REC = $55; {/* 本地开始录像*/}
const
  MINOR_LOCAL_STOP_REC = $56; {/* 本地停止录像*/}
const
  MINOR_LOCAL_PTZCTRL = $57; {/* 本地云台控制*/}
const
  MINOR_LOCAL_PREVIEW = $58; {/* 本地预览 (保留不使用)*/}
const
  MINOR_LOCAL_MODIFY_TIME = $59; {/* 本地修改时间(保留不使用)*/}
const
  MINOR_LOCAL_UPGRADE = $5A; {/* 本地升级*/}
const
  MINOR_LOCAL_RECFILE_OUTPUT = $5B; {/* 本地备份录象文件*/}
const
  MINOR_LOCAL_FORMAT_HDD = $5C; {/* 本地初始化硬盘*/}
const
  MINOR_LOCAL_CFGFILE_OUTPUT = $5D; {/* 导出本地配置文件*/}
const
  MINOR_LOCAL_CFGFILE_INPUT = $5E; {/* 导入本地配置文件*/}
const
  MINOR_LOCAL_COPYFILE = $5; {/* 本地备份文件*/}
const
  MINOR_LOCAL_LOCKFILE = $60; {/* 本地锁定录像文件*/}
const
  MINOR_LOCAL_UNLOCKFILE = $61; {/* 本地解锁录像文件*/}
const
  MINOR_LOCAL_DVR_ALARM = $62; {/* 本地手动清除和触发报警*/}
const
  MINOR_IPC_ADD = $63; {/* 本地添加IPC*/}
const
  MINOR_IPC_DEL = $64; {/* 本地删除IPC*/}
const
  MINOR_IPC_SET = $65; {/* 本地设置IPC*/}
const
  MINOR_LOCAL_START_BACKUP = $66; {/* 本地开始备份*/}
const
  MINOR_LOCAL_STOP_BACKUP = $67; {/* 本地停止备份*/}
const
  MINOR_LOCAL_COPYFILE_START_TIME = $68; {/* 本地备份开始时间*/}
const
  MINOR_LOCAL_COPYFILE_END_TIME = $69; {/* 本地备份结束时间*/}


const
  MINOR_REMOTE_LOGIN = $70; {/* 远程登录*/}
const
  MINOR_REMOTE_LOGOUT = $71; {/* 远程注销登陆*/}
const
  MINOR_REMOTE_START_REC = $72; {/* 远程开始录像*/}
const
  MINOR_REMOTE_STOP_REC = $73; {/* 远程停止录像*/}
const
  MINOR_START_TRANS_CHAN = $74; {/* 开始透明传输*/}
const
  MINOR_STOP_TRANS_CHAN = $75; {/* 停止透明传输*/}
const
  MINOR_REMOTE_GET_PARM = $76; {/* 远程获取参数*/}
const
  MINOR_REMOTE_CFG_PARM = $77; {/* 远程配置参数*/}
const
  MINOR_REMOTE_GET_STATUS = $78; {/* 远程获取状态*/}
const
  MINOR_REMOTE_ARM = $79; {/* 远程布防*/}
const
  MINOR_REMOTE_DISARM = $7A; {/* 远程撤防*/}
const
  MINOR_REMOTE_REBOOT = $7B; {/* 远程重启*/}
const
  MINOR_START_VT = $7C; {/* 开始语音对讲*/}
const
  MINOR_STOP_VT = $7D; {/* 停止语音对讲*/}
const
  MINOR_REMOTE_UPGRADE = $7E; {/* 远程升级*/}
const
  MINOR_REMOTE_PLAYBYFILE = $7; {/* 远程按文件回放*/}
const
  MINOR_REMOTE_PLAYBYTIME = $80; {/* 远程按时间回放*/}
const
  MINOR_REMOTE_PTZCTRL = $81; {/* 远程云台控制*/}
const
  MINOR_REMOTE_FORMAT_HDD = $82; {/* 远程格式化硬盘*/}
const
  MINOR_REMOTE_STOP = $83; {/* 远程关机*/}
const
  MINOR_REMOTE_LOCKFILE = $84; {/* 远程锁定文件*/}
const
  MINOR_REMOTE_UNLOCKFILE = $85; {/* 远程解锁文件*/}
const
  MINOR_REMOTE_CFGFILE_OUTPUT = $86; {/* 远程导出配置文件*/}
const
  MINOR_REMOTE_CFGFILE_INTPUT = $87; {/* 远程导入配置文件*/}
const
  MINOR_REMOTE_RECFILE_OUTPUT = $88; {/* 远程导出录象文件*/}
const
  MINOR_REMOTE_DVR_ALARM = $89; {/* 远程手动清除和触发报警*/}
const
  MINOR_REMOTE_IPC_ADD = $8A; {/* 远程添加IPC*/}
const
  MINOR_REMOTE_IPC_DEL = $8B; {/* 远程删除IPC*/}
const
  MINOR_REMOTE_IPC_SET = $8C; {/* 远程设置IPC*/}


{+//日志附加信息*/ }
{///主类型 }
const
  MAJOR_INFORMATION = $4; {/*附加信息*/}
{///次类型 }
const
  MINOR_HDD_INFO = $A1; {/*硬盘信息*/}
const
  MINOR_SMART_INFO = $A2; {/*SMART信息*/}
const
  MINOR_REC_START = $A3; {/*开始录像*/}
const
  MINOR_REC_STOP = $A4; {/*停止录像*/}
const
  MINOR_REC_OVERDUE = $A5; {/*过期录像删除*/}

{///当日志的主类型为MAJOR_OPERATION=03，次类型为MINOR_LOCAL_CFG_PARM=0x52或者MINOR_REMOTE_GET_PARM=0x76或者MINOR_REMOTE_CFG_PARM=0x77时，dwParaType:参数类型有效，其含义如下： }
const
  PARA_VIDEOOUT = $1;
const
  PARA_IMAGE = $2;
const
  PARA_ENCODE = $4;
const
  PARA_NETWORK = $8;
const
  PARA_ALARM = $10;
const
  PARA_EXCEPTION = $20;
const
  PARA_DECODER = $40; {/*解码器*/}
const
  PARA_RS232 = $80;
const
  PARA_PREVIEW = $100;
const
  PARA_SECURITY = $200;
const
  PARA_DATETIME = $400;
const
  PARA_FRAMETYPE = $800; {/*帧格式*/}

{///日志信息(9000扩展) }
type
  NET_DVR_LOG_V30 = record
    strLogTime: NET_DVR_TIME;
    dwMajorType: LongInt;
    dwMinorType: LongInt;
    sPanelUser: array[0..MAX_NAMELEN - 1] of BYTE;
    sNetUser: array[0..MAX_NAMELEN - 1] of BYTE;
    struRemoteHostAddr: NET_DVR_IPADDR;
    dwParaType: LongInt;
    dwChannel: LongInt;
    dwDiskNumber: LongInt;
    dwAlarmInPort: LongInt;
    dwAlarmOutPort: LongInt;
    dwInfoLen: LongInt;
    sInfo: array[0..LOG_INFO_LEN - 1] of Char;
  end {NET_DVR_LOG_V30};
  LPNET_DVR_LOG_V30 = ^NET_DVR_LOG_V30;

{///日志信息 }
type
  NET_DVR_LOG = record
    strLogTime: NET_DVR_TIME;
    dwMajorType: LongInt;
    dwMinorType: LongInt;
    sPanelUser: array[0..MAX_NAMELEN - 1] of BYTE;
    sNetUser: array[0..MAX_NAMELEN - 1] of BYTE;
    sRemoteHostAddr: array[0..16 - 1] of Char;
    dwParaType: LongInt;
    dwChannel: LongInt;
    dwDiskNumber: LongInt;
    dwAlarmInPort: LongInt;
    dwAlarmOutPort: LongInt;
  end {NET_DVR_LOG};
  LPNET_DVR_LOG = ^NET_DVR_LOG;

{+//***********************DVR日志 end***************************/ }


{///报警输出状态(9000扩展) }
type
  NET_DVR_ALARMOUTSTATUS_V30 = record
    Output: array[0..MAX_ALARMOUT_V30 - 1] of BYTE;
  end {NET_DVR_ALARMOUTSTATUS_V30};
  LPNET_DVR_ALARMOUTSTATUS_V30 = ^NET_DVR_ALARMOUTSTATUS_V30;

{///报警输出状态 }
type
  NET_DVR_ALARMOUTSTATUS = record
    Output: array[0..MAX_ALARMOUT - 1] of BYTE;
  end {NET_DVR_ALARMOUTSTATUS};
  LPNET_DVR_ALARMOUTSTATUS = ^NET_DVR_ALARMOUTSTATUS;

{///交易信息 }
type
  NET_DVR_TRADEINFO = record
    m_Year: Word;
    m_Month: Word;
    m_Day: Word;
    m_Hour: Word;
    m_Minute: Word;
    m_Second: Word;
    DeviceName: array[0..24 - 1] of BYTE;
    dwChannelNumer: LongInt;
    CardNumber: array[0..32 - 1] of BYTE;
    cTradeType: array[0..12 - 1] of Char;
    dwCash: LongInt;
  end {NET_DVR_TRADEINFO};
  LPNET_DVR_TRADEINFO = ^NET_DVR_TRADEINFO;


{///ATM专用 }
{+//***************************ATM(begin)***************************/ }
const
  NCR = 0;
const
  DIEBOLD = 1;
const
  WINCOR_NIXDORF = 2;
const
  SIEMENS = 3;
const
  OLIVETTI = 4;
const
  FUJITSU = 5;
const
  HITACHI = 6;
const
  SMI = 7;
const
  IBM = 8;
const
  BULL = 9;
const
  YiHua = 10;
const
  LiDe = 11;
const
  GDYT = 12;
const
  Mini_Banl = 13;
const
  GuangLi = 14;
const
  DongXin = 15;
const
  ChenTong = 16;
const
  NanTian = 17;
const
  XiaoXing = 18;
const
  GZYY = 19;
const
  QHTLT = 20;
const
  DRS918 = 21;
const
  KALATEL = 22;
const
  NCR_2 = 23;
const
  NXS = 24;


{+//帧格式*/ }
type
  NET_DVR_FRAMETYPECODE = record
    code: array[0..12 - 1] of BYTE;
{= 代码 }
  end {NET_DVR_FRAMETYPECODE};

{///ATM参数(9000扩展) }
type
  NET_DVR_FRAMEFORMAT_V30 = record
    dwSize: LongInt;
    struATMIP: NET_DVR_IPADDR;
{= ATM IP地址 }
    dwATMType: LongInt;
{= ATM类型 }
    dwInputMode: LongInt;
{= 输入方式 0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入 }
    dwFrameSignBeginPos: LongInt;
{= 报文标志位的起始位置 }
    dwFrameSignLength: LongInt;
{= 报文标志位的长度 }
    byFrameSignContent: array[0..12 - 1] of BYTE;
{= 报文标志位的内容 }
    dwCardLengthInfoBeginPos: LongInt;
{= 卡号长度信息的起始位置 }
    dwCardLengthInfoLength: LongInt;
{= 卡号长度信息的长度 }
    dwCardNumberInfoBeginPos: LongInt;
{= 卡号信息的起始位置 }
    dwCardNumberInfoLength: LongInt;
{= 卡号信息的长度 }
    dwBusinessTypeBeginPos: LongInt;
{= 交易类型的起始位置 }
    dwBusinessTypeLength: LongInt;
{= 交易类型的长度 }
    frameTypeCode: array[0..10 - 1] of NET_DVR_FRAMETYPECODE;
{= 类型 }
    wATMPort: Word;
{= 卡号捕捉端口号(网络协议方式) }
    wProtocolType: Word;
{= 网络协议类型 }
    byRes: array[0..24 - 1] of BYTE;
  end {NET_DVR_FRAMEFORMAT_V30};
  LPNET_DVR_FRAMEFORMAT_V30 = ^NET_DVR_FRAMEFORMAT_V30;

{///ATM参数 }
type
  NET_DVR_FRAMEFORMAT = record
    dwSize: LongInt;
    sATMIP: array[0..16 - 1] of Char;
{= ATM IP地址 }
    dwATMType: LongInt;
{= ATM类型 }
    dwInputMode: LongInt;
{= 输入方式 0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入 }
    dwFrameSignBeginPos: LongInt;
{= 报文标志位的起始位置 }
    dwFrameSignLength: LongInt;
{= 报文标志位的长度 }
    byFrameSignContent: array[0..12 - 1] of BYTE;
{= 报文标志位的内容 }
    dwCardLengthInfoBeginPos: LongInt;
{= 卡号长度信息的起始位置 }
    dwCardLengthInfoLength: LongInt;
{= 卡号长度信息的长度 }
    dwCardNumberInfoBeginPos: LongInt;
{= 卡号信息的起始位置 }
    dwCardNumberInfoLength: LongInt;
{= 卡号信息的长度 }
    dwBusinessTypeBeginPos: LongInt;
{= 交易类型的起始位置 }
    dwBusinessTypeLength: LongInt;
{= 交易类型的长度 }
    frameTypeCode: array[0..10 - 1] of NET_DVR_FRAMETYPECODE;
{= 类型 }
  end {NET_DVR_FRAMEFORMAT};
  LPNET_DVR_FRAMEFORMAT = ^NET_DVR_FRAMEFORMAT;


{+//****************************DS-6001D/F(begin)***************************/ }
{///DS-6001D Decoder }
type
  NET_DVR_DECODERINFO = record
    byEncoderIP: array[0..16 - 1] of BYTE;
    byEncoderUser: array[0..16 - 1] of BYTE;
    byEncoderPasswd: array[0..16 - 1] of BYTE;
    bySendMode: BYTE;
    byEncoderChannel: BYTE;
    wEncoderPort: Word;
    reservedData: array[0..4 - 1] of BYTE;
  end {NET_DVR_DECODERINFO};
  LPNET_DVR_DECODERINFO = ^NET_DVR_DECODERINFO;

type
  NET_DVR_DECODERSTATE = record
    byEncoderIP: array[0..16 - 1] of BYTE;
    byEncoderUser: array[0..16 - 1] of BYTE;
    byEncoderPasswd: array[0..16 - 1] of BYTE;
    byEncoderChannel: BYTE;
    bySendMode: BYTE;
    wEncoderPort: Word;
    dwConnectState: LongInt;
    reservedData: array[0..4 - 1] of BYTE;
  end {NET_DVR_DECODERSTATE};
  LPNET_DVR_DECODERSTATE = ^NET_DVR_DECODERSTATE;

{+//解码设备控制码定义*/ }
const
  NET_DEC_STARTDEC = 1;
const
  NET_DEC_STOPDEC = 2;
const
  NET_DEC_STOPCYCLE = 3;
const
  NET_DEC_CONTINUECYCLE = 4;
{+//连接的通道配置*/ }
type
  NET_DVR_DECCHANINFO = record
    sDVRIP: array[0..16 - 1] of Char;
{= DVR IP地址 }
    wDVRPort: Word;
{= 端口号 }
    sUserName: array[0..NAME_LEN - 1] of BYTE;
{= 用户名 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
{= 密码 }
    byChannel: BYTE;
{= 通道号 }
    byLinkMode: BYTE;
{= 连接模式 }
    byLinkType: BYTE;
{= 连接类型 0－主码流 1－子码流 }
  end {NET_DVR_DECCHANINFO};
  LPNET_DVR_DECCHANINFO = ^NET_DVR_DECCHANINFO;

{+//每个解码通道的配置*/ }
type
  NET_DVR_DECINFO = record
    byPoolChans: BYTE;
{=每路解码通道上的循环通道数量, 最多4通道 0表示没有解码 }
    struchanConInfo: array[0..MAX_DECPOOLNUM - 1] of NET_DVR_DECCHANINFO;
    byEnablePoll: BYTE;
{=是否轮巡 0-否 1-是 }
    byPoolTime: BYTE;
{=轮巡时间 0-保留 1-10秒 2-15秒 3-20秒 4-30秒 5-45秒 6-1分钟 7-2分钟 8-5分钟 }
  end {NET_DVR_DECINFO};
  LPNET_DVR_DECINFO = ^NET_DVR_DECINFO;

{+//整个设备解码配置*/ }
type
  NET_DVR_DECCFG = record
    dwSize: LongInt;
    dwDecChanNum: LongInt;
{=解码通道的数量 }
    struDecInfo: array[0..MAX_DECNUM - 1] of NET_DVR_DECINFO;
  end {NET_DVR_DECCFG};
  LPNET_DVR_DECCFG = ^NET_DVR_DECCFG;

{///2005-08-01 }
{+// 解码设备透明通道设置*/ }
type
  NET_DVR_PORTINFO = record
    dwEnableTransPort: LongInt;
{= 是否启动透明通道 0－不启用 1－启用 }
    sDecoderIP: array[0..16 - 1] of Char;
{= DVR IP地址 }
    wDecoderPort: Word;
{= 端口号 }
    wDVRTransPort: Word;
{= 配置前端DVR是从485/232输出，1表示232串口,2表示485串口 }
    cReserve: array[0..4 - 1] of Char;
  end {NET_DVR_PORTINFO};
  LPNET_DVR_PORTINFO = ^NET_DVR_PORTINFO;

type
  NET_DVR_PORTCFG = record
    dwSize: LongInt;
    struTransPortInfo: array[0..MAX_TRANSPARENTNUM - 1] of NET_DVR_PORTINFO;
{= 数组0表示232 数组1表示485 }
  end {NET_DVR_PORTCFG};
  LPNET_DVR_PORTCFG = ^NET_DVR_PORTCFG;

{+// 控制网络文件回放*/ }
type
  Tbytime = record
    dwChannel: Longword;
    sUserName: array[0..NAME_LEN - 1] of Byte;
    sPassword: array[0..PASSWD_LEN - 1] of Byte;
    struStartTime: NET_DVR_TIME;
    struStopTime: NET_DVR_TIME;
  end;

  Tmode_size = record
    case Integer of
      0: (byFile: array[0..99] of Byte);
      1: (byTime: Tbytime);
  end;

  NET_DVR_PLAYREMOTEFILE = record
    dwSize: Longword;
    sDecoderIP: array[0..16 - 1] of Char;
    wDecoderPort: Word; //Port no.
    wLoadMode: Word; //回放下载模式 1－按名字 2－按时间
    mode_size: Tmode_size;
  end;
  LPNET_DVR_PLAYREMOTEFILE = ^NET_DVR_PLAYREMOTEFILE;


{+//当前设备解码连接状态*/ }
type
  TuserInfo = record
    sUserName: array[0..NAME_LEN - 1] of Byte; //请求视频用户名
    sPassword: array[0..PASSWD_LEN - 1] of Byte; //密码
    cReserve: array[0..51] of Char;
  end;
  TfileInfo = record
    fileName: array[0..99] of Byte;
  end;
  TtimeInfo = record
    dwChannel: Longword;
    sUserName: array[0..NAME_LEN - 1] of Byte; //请求视频用户名
    sPassword: array[0..PASSWD_LEN - 1] of Byte; //密码
    struStartTime: NET_DVR_TIME; //按时间回放的开始时间
    struStopTime: NET_DVR_TIME; //按时间回放的结束时间
  end;
  TobjectInfo = record
    case Integer of
      0: (userInfo: TuserInfo);
      1: (fileInfo: TfileInfo);
      2: (timeInfo: TtimeInfo);
  end;

  NET_DVR_DECCHANSTATUS = record
    dwWorkType: Longword; //工作方式：1：轮巡、2：动态连接解码、3：文件回放下载 4：按时间回放下载
    sDVRIP: array[0..16 - 1] of Char; //连接的设备ip
    wDVRPort: Word; //连接端口号
    byChannel: Byte; //通道号
    byLinkMode: Byte; //连接模式
    dwLinkType: Longword; //连接类型 0－主码流 1－子码流
    objectInfo: TobjectInfo;
  end;
  LPNET_DVR_DECCHANSTATUS = ^NET_DVR_DECCHANSTATUS;

type
  NET_DVR_DECSTATUS = record
    dwSize: LongInt;
    struDecState: array[0..MAX_DECNUM - 1] of NET_DVR_DECCHANSTATUS;
  end {NET_DVR_DECSTATUS};
  LPNET_DVR_DECSTATUS = ^NET_DVR_DECSTATUS;
{+//****************************DS-6001D/F(end)***************************/ }

{///单字符参数(子结构) }
type
  NET_DVR_SHOWSTRINGINFO = record
    wShowString: Word;
    wStringSize: Word;
{= 该行字符的长度，不能大于44个字符 }
    wShowStringTopLeftX: Word;
{= 字符显示位置的x坐标 }
    wShowStringTopLeftY: Word;
{= 字符名称显示位置的y坐标 }
    sString: array[0..44 - 1] of Char;
{= 要显示的字符内容 }
  end {NET_DVR_SHOWSTRINGINFO};
  LPNET_DVR_SHOWSTRINGINFO = ^NET_DVR_SHOWSTRINGINFO;

{///叠加字符(9000扩展) }
type
  NET_DVR_SHOWSTRING_V30 = record
    dwSize: LongInt;
    struStringInfo: array[0..MAX_STRINGNUM_V30 - 1] of NET_DVR_SHOWSTRINGINFO;
{= 要显示的字符内容 }
  end {NET_DVR_SHOWSTRING_V30};
  LPNET_DVR_SHOWSTRING_V30 = ^NET_DVR_SHOWSTRING_V30;

{///叠加字符扩展(8条字符) }
type
  NET_DVR_SHOWSTRING_EX = record
    dwSize: LongInt;
    struStringInfo: array[0..MAX_STRINGNUM_EX - 1] of NET_DVR_SHOWSTRINGINFO;
{= 要显示的字符内容 }
  end {NET_DVR_SHOWSTRING_EX};
  LPNET_DVR_SHOWSTRING_EX = ^NET_DVR_SHOWSTRING_EX;

{///叠加字符 }
type
  NET_DVR_SHOWSTRING = record
    dwSize: LongInt;
    struStringInfo: array[0..MAX_STRINGNUM - 1] of NET_DVR_SHOWSTRINGINFO;
{= 要显示的字符内容 }
  end {NET_DVR_SHOWSTRING};
  LPNET_DVR_SHOWSTRING = ^NET_DVR_SHOWSTRING;

{+//***************************DS9000新增结构(begin)******************************/ }

{-EMAIL参数结构 }
type
  TstruSender = record
    sName: array[0..NAME_LEN - 1] of Byte; //发件人姓名
    sAddress: array[0..MAX_DOMAIN_NAME - 1] of Byte; //发件人地址
  end;
  TstruReceiver = record
    sName: array[0..NAME_LEN - 1] of BYTE; //收件人姓名
    sAddress: array[0..MAX_DOMAIN_NAME - 1] of BYTE; //收件人地址
  end;

  NET_DVR_EMAILCFG_V30 = record
    dwSize: Longword;
    sAccount: array[0..NAME_LEN - 1] of BYTE; //账号
    sPassword: array[0..PASSWD_LEN - 1] of BYTE; //密码
    struSender: TstruSender;
    sSmtpServer: array[0..MAX_DOMAIN_NAME - 1] of Byte; //smpt服务器
    sPop3Server: array[0..MAX_DOMAIN_NAME - 1] of byte; //POP3服务器
    struReceiver: array[0..3 - 1] of TstruReceiver;
    byAttachment: Byte; //是否带附件
    bySmtpServerVerify: Byte; //发送服务器要求身份验证
    byMailInterval: Byte; //mail interval
    res: array[0..77 - 1] of Byte;
  end;
  LPNET_DVR_EMAILCFG_V30 = ^NET_DVR_EMAILCFG_V30;

{+// }
{-DVR实现巡航数据结构 }
{= }
type
  NET_DVR_CRUISE_PARA = record
    dwSize: LongInt;
    byPresetNo: array[0..CRUISE_MAX_PRESET_NUMS - 1] of BYTE;
{= 预置点号 }
    byCruiseSpeed: array[0..CRUISE_MAX_PRESET_NUMS - 1] of BYTE;
{= 巡航速度 }
    wDwellTime: array[0..CRUISE_MAX_PRESET_NUMS - 1] of Word;
{= 停留时间 }
    byEnableThisCruise: BYTE;
{= 是否启用 }
    res: array[0..15 - 1] of BYTE;
  end {NET_DVR_CRUISE_PARA};
  LPNET_DVR_CRUISE_PARA = ^NET_DVR_CRUISE_PARA;
{+//***************************DS9000新增结构(end)******************************/ }


{///时间点 }
type
  NET_DVR_TIMEPOINT = record
    dwMonth: LongInt;
    dwWeekNo: LongInt;
    dwWeekDate: LongInt;
    dwHour: LongInt;
    dwMin: LongInt;
  end {NET_DVR_TIMEPOINT};

{///夏令时参数 }
type
  NET_DVR_ZONEANDDST = record
    dwSize: LongInt;
    byRes1: array[0..16 - 1] of BYTE;
    dwEnableDST: LongInt;
    byDSTBias: BYTE;
    byRes2: array[0..3 - 1] of BYTE;
    struBeginPoint: NET_DVR_TIMEPOINT;
    struEndPoint: NET_DVR_TIMEPOINT;
  end {NET_DVR_ZONEANDDST};
  LPNET_DVR_ZONEANDDST = ^NET_DVR_ZONEANDDST;



{///图片质量 }
type
  NET_DVR_JPEGPARA = record
{+//注意：当图像压缩分辨率为VGA时，支持0=CIF, 1=QCIF, 2=D1抓图， }
{-当分辨率为3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA,7=XVGA, 8=HD900p }
{=仅支持当前分辨率的抓图 }
    wPicSize: Word;
{= 0=CIF, 1=QCIF, 2=D1 3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA }
    wPicQuality: Word;
{= 图片质量系数 0-最好 1-较好 2-一般 }
  end {NET_DVR_JPEGPARA};
  LPNET_DVR_JPEGPARA = ^NET_DVR_JPEGPARA;

{+// aux video out parameter*/ }
{///辅助输出参数配置 }
type
  NET_DVR_AUXOUTCFG = record
    dwSize: LongInt;
    dwAlarmOutChan: LongInt;
{= 选择报警弹出大报警通道切换时间：1画面的输出通道: 0:主输出/1:辅1/2:辅2/3:辅3/4:辅4 }
    dwAlarmChanSwitchTime: LongInt;
{= :1秒 - 10:10秒 }
    dwAuxSwitchTime: array[0..MAX_AUXOUT - 1] of LongInt;
{= 辅助输出切换时间: 0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s }
    byAuxOrder: array[0..MAX_AUXOUT - 1, 0..MAX_WINDOW - 1] of BYTE;
{= 辅助输出预览顺序, 0xff表示相应的窗口不预览 }
  end {NET_DVR_AUXOUTCFG};
  LPNET_DVR_AUXOUTCFG = ^NET_DVR_AUXOUTCFG;


{///ntp }
type
  NET_DVR_NTPPARA = record
    sNTPServer: array[0..64 - 1] of BYTE;
{= Domain Name or IP addr of NTP server }
    wInterval: Word;
{= adjust time interval(hours) }
    byEnableNTP: BYTE;
{= enable NPT client 0-no，1-yes }
    cTimeDifferenceH: Char;
{= 与国际标准时间的 小时偏移-12 ... +13 }
    cTimeDifferenceM: Char;
{= 与国际标准时间的 分钟偏移0, 30, 45 }
    res1: BYTE;
    wNtpPort: Word;
{= ntp server port 9000新增 设备默认为123 }
    res2: array[0..8 - 1] of BYTE;
  end {NET_DVR_NTPPARA};
  LPNET_DVR_NTPPARA = ^NET_DVR_NTPPARA;

{///ddns }
type
  NET_DVR_DDNSPARA = record
    sUsername: array[0..NAME_LEN - 1] of BYTE;
{= DDNS账号用户名/密码 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
    sDomainName: array[0..64 - 1] of BYTE;
{= 域名 }
    byEnableDDNS: BYTE;
{=是否应用 0-否，1-是 }
    res: array[0..15 - 1] of BYTE;
  end {NET_DVR_DDNSPARA};
  LPNET_DVR_DDNSPARA = ^NET_DVR_DDNSPARA;


type
  NET_DVR_DDNSPARA_EX = record
    byHostIndex: BYTE;
{= 0-Hikvision DNS(保留) 1－Dyndns 2－PeanutHull(花生壳), 3-希网3322 }
    byEnableDDNS: BYTE;
{=是否应用DDNS 0-否，1-是 }
    wDDNSPort: Word;
{= DDNS端口号 }
    sUsername: array[0..NAME_LEN - 1] of BYTE;
{= DDNS用户名 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
{= DDNS密码 }
    sDomainName: array[0..MAX_DOMAIN_NAME - 1] of BYTE;
{= 设备配备的域名地址 }
    sServerName: array[0..MAX_DOMAIN_NAME - 1] of BYTE;
{= DDNS 对应的服务器地址，可以是IP地址或域名 }
    byRes: array[0..16 - 1] of BYTE;
  end {NET_DVR_DDNSPARA_EX};
  LPNET_DVR_DDNSPARA_EX = ^NET_DVR_DDNSPARA_EX;

{///9000扩展 }
type
  TstruDDNS = record
    sUsername: array[0..NAME_LEN - 1] of BYTE; //DDNS账号用户名
    sPassword: array[0..PASSWD_LEN - 1] of BYTE; //密码 }
    sDomainName: array[0..MAX_DOMAIN_NAME - 1] of BYTE; //设备配备的域名地址
    sServerName: array[0..MAX_DOMAIN_NAME - 1] of BYTE; //DDNS协议对应的服务器地址，可以是IP地址或域名
    wDDNSPort: Word; //端口号
    byRes: array[0..10 - 1] of BYTE;
  end;

  NET_DVR_DDNSPARA_V30 = record
    byEnableDDNS: BYTE;
    byHostIndex: BYTE; //0-Hikvision DNS(保留) 1－Dyndns 2－PeanutHull(花生壳) 3-希网3322
    byRes1: array[0..2 - 1] of BYTE;
    struDDNS: array[0..MAX_DDNS_NUMS - 1] of TstruDDNS;
    byRes2: array[0..16 - 1] of Byte;
  end;
  LPNET_DVR_DDNSPARA_V30 = ^NET_DVR_DDNSPARA_V30;


{///email }
type
  NET_DVR_EMAILPARA = record
    sUsername: array[0..64 - 1] of BYTE;
{= 邮件账号/密码 }
    sPassword: array[0..64 - 1] of BYTE;
    sSmtpServer: array[0..64 - 1] of BYTE;
    sPop3Server: array[0..64 - 1] of BYTE;
    sMailAddr: array[0..64 - 1] of BYTE;
{= email }
    sEventMailAddr1: array[0..64 - 1] of BYTE;
{= 上传报警/异常等的email }
    sEventMailAddr2: array[0..64 - 1] of BYTE;
    res: array[0..16 - 1] of BYTE;
  end {NET_DVR_EMAILPARA};
  LPNET_DVR_EMAILPARA = ^NET_DVR_EMAILPARA;

{///网络参数配置 }
type
  NET_DVR_NETAPPCFG = record
    dwSize: LongInt;
    sDNSIp: array[0..16 - 1] of Char;
{= DNS服务器地址 }
    struNtpClientParam: NET_DVR_NTPPARA;
{= NTP参数 }
    struDDNSClientParam: NET_DVR_DDNSPARA;
{= DDNS参数 }
    res: array[0..464 - 1] of BYTE;
{= 保留 }
  end {NET_DVR_NETAPPCFG};
  LPNET_DVR_NETAPPCFG = ^NET_DVR_NETAPPCFG;

{///nfs结构配置 }
type
  NET_DVR_SINGLE_NFS = record
    sNfsHostIPAddr: array[0..16 - 1] of Char;
    sNfsDirectory: array[0..PATHNAME_LEN - 1] of BYTE;
  end {NET_DVR_SINGLE_NFS};
  LPNET_DVR_SINGLE_NFS = ^NET_DVR_SINGLE_NFS;

type
  NET_DVR_NFSCFG = record
    dwSize: LongInt;
    struNfsDiskParam: array[0..MAX_NFS_DISK - 1] of NET_DVR_SINGLE_NFS;
  end {NET_DVR_NFSCFG};
  LPNET_DVR_NFSCFG = ^NET_DVR_NFSCFG;

{///巡航点配置(HIK IP快球专用) }
type
  NET_DVR_CRUISE_POINT = record
    PresetNum: BYTE;
    Dwell: BYTE;
    Speed: BYTE;
    Reserve: BYTE;
  end {NET_DVR_CRUISE_POINT};
  LPNET_DVR_CRUISE_POINT = ^NET_DVR_CRUISE_POINT;

type
  NET_DVR_CRUISE_RET = record
    struCruisePoint: array[0..32 - 1] of NET_DVR_CRUISE_POINT;
  end {NET_DVR_CRUISE_RET};
  LPNET_DVR_CRUISE_RET = ^NET_DVR_CRUISE_RET;

{///8000-2.2 }
{///所有硬盘配置参数 }
type
  tagNET_DVR_ALL_HD_CFG = record
    dwSize: LongInt;
    byThreshold: BYTE;
    byRes: array[0..4 - 1] of BYTE;
  end {tagNET_DVR_ALL_HD_CFG};


{+//***********************************多路解码器(begin)***************************************/ }
type
  NET_DVR_NETCFG_OTHER = record
    dwSize: LongInt;
    sFirstDNSIP: array[0..16 - 1] of Char;
    sSecondDNSIP: array[0..16 - 1] of Char;
    sRes: array[0..32 - 1] of Char;
  end {NET_DVR_NETCFG_OTHER};
  LPNET_DVR_NETCFG_OTHER = ^NET_DVR_NETCFG_OTHER;

type
  NET_DVR_MATRIX_DECINFO = record
    sDVRIP: array[0..16 - 1] of Char;
{= DVR IP地址 }
    wDVRPort: Word;
{= 端口号 }
    byChannel: BYTE;
{= 通道号 }
    byTransProtocol: BYTE;
{= 传输协议类型 0-TCP, 1-UDP }
    byTransMode: BYTE;
{= 传输码流模式 0－主码流 1－子码流 }
    byRes: array[0..3 - 1] of BYTE;
    sUserName: array[0..NAME_LEN - 1] of BYTE;
{= 监控主机登陆帐号 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
{= 监控主机密码 }
  end {NET_DVR_MATRIX_DECINFO};
  LPNET_DVR_MATRIX_DECINFO = ^NET_DVR_MATRIX_DECINFO;

{///启动/停止动态解码 }
type
  NET_DVR_MATRIX_DYNAMIC_DEC = record
    dwSize: LongInt;
    struDecChanInfo: NET_DVR_MATRIX_DECINFO;
{= 动态解码通道信息 }
  end {NET_DVR_MATRIX_DYNAMIC_DEC};
  LPNET_DVR_MATRIX_DYNAMIC_DEC = ^NET_DVR_MATRIX_DYNAMIC_DEC;

type
  NET_DVR_MATRIX_DEC_CHAN_STATUS = record
    dwSize: LongInt;
    dwIsLinked: LongInt;
{= 解码通道状态 0－休眠 1－正在连接 2－已连接 3-正在解码 }
    dwStreamCpRate: LongInt;
{= Stream copy rate, X kbits/second }
    cRes: array[0..64 - 1] of Char;
{= 保留 }
  end {NET_DVR_MATRIX_DEC_CHAN_STATUS};
  LPNET_DVR_MATRIX_DEC_CHAN_STATUS = ^NET_DVR_MATRIX_DEC_CHAN_STATUS;

type
  NET_DVR_MATRIX_DEC_CHAN_INFO = record
    dwSize: LongInt;
    struDecChanInfo: NET_DVR_MATRIX_DECINFO;
{= 解码通道信息 }
    dwDecState: LongInt;
{= 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 }
    StartTime: NET_DVR_TIME;
{= 按时间回放开始时间 }
    StopTime: NET_DVR_TIME;
{= 按时间回放停止时间 }
    sFileName: array[0..128 - 1] of Char;
{= 按文件回放文件名 }
  end {NET_DVR_MATRIX_DEC_CHAN_INFO};
  LPNET_DVR_MATRIX_DEC_CHAN_INFO = ^NET_DVR_MATRIX_DEC_CHAN_INFO;

{///连接的通道配置 2007-11-05 }
type
  NET_DVR_MATRIX_DECCHANINFO = record
    dwEnable: LongInt;
{= 是否启用 0－否 1－启用 }
    struDecChanInfo: NET_DVR_MATRIX_DECINFO;
{= 轮循解码通道信息 }
  end {NET_DVR_MATRIX_DECCHANINFO};
  LPNET_DVR_MATRIX_DECCHANINFO = ^NET_DVR_MATRIX_DECCHANINFO;

{///2007-11-05 新增每个解码通道的配置 }
type
  NET_DVR_MATRIX_LOOP_DECINFO = record
    dwSize: LongInt;
    dwPoolTime: LongInt;
{=轮巡时间 }
    struchanConInfo: array[0..MAX_CYCLE_CHAN - 1] of NET_DVR_MATRIX_DECCHANINFO;
  end {NET_DVR_MATRIX_LOOP_DECINFO};
  LPNET_DVR_MATRIX_LOOP_DECINFO = ^NET_DVR_MATRIX_LOOP_DECINFO;

{///2007-12-22 }
type
  TTY_CONFIG = record
    baudrate: BYTE;
{= 波特率 }
    databits: BYTE;
{= 数据位 }
    stopbits: BYTE;
{= 停止位 }
    parity: BYTE;
{= 奇偶校验位 }
    flowcontrol: BYTE;
{= 流控 }
    res: array[0..3 - 1] of BYTE;
  end {TTY_CONFIG};
  LPTTY_CONFIG = ^TTY_CONFIG;

type
  NET_DVR_MATRIX_TRAN_CHAN_INFO = record
    byTranChanEnable: BYTE;
{= 当前透明通道是否打开 0：关闭 1：打开 }
{+// }
{-* 多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下： }
{-* 0 RS485 }
{-* 1 RS232 Console }
{= }
    byLocalSerialDevice: BYTE;
{= Local serial device }
{+// }
{-* 远程串口输出还是两个,一个RS232，一个RS485 }
{-* 1表示232串口 }
{-* 2表示485串口 }
{= }
    byRemoteSerialDevice: BYTE;
{= Remote output serial device }
    res1: BYTE;
{= 保留 }
    sRemoteDevIP: array[0..16 - 1] of Char;
{= Remote Device IP }
    wRemoteDevPort: Word;
{= Remote Net Communication Port }
    res2: array[0..2 - 1] of BYTE;
{= 保留 }
    RemoteSerialDevCfg: TTY_CONFIG;
  end {NET_DVR_MATRIX_TRAN_CHAN_INFO};
  LPNET_DVR_MATRIX_TRAN_CHAN_INFO = ^NET_DVR_MATRIX_TRAN_CHAN_INFO;

type
  NET_DVR_MATRIX_TRAN_CHAN_CONFIG = record
    dwSize: LongInt;
    by232IsDualChan: BYTE;
{= 设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM }
    by485IsDualChan: BYTE;
{= 设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM }
    res: array[0..2 - 1] of BYTE;
{= 保留 }
    struTranInfo: array[0..MAX_SERIAL_NUM - 1] of NET_DVR_MATRIX_TRAN_CHAN_INFO;
{=同时支持建立MAX_SERIAL_NUM个透明通道 }
  end {NET_DVR_MATRIX_TRAN_CHAN_CONFIG};
  LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG = ^NET_DVR_MATRIX_TRAN_CHAN_CONFIG;

{///2007-12-24 Merry Christmas Eve... }
type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY = record
    dwSize: LongInt;
    sDVRIP: array[0..16 - 1] of Char;
{= DVR IP地址 }
    wDVRPort: Word;
{= 端口号 }
    byChannel: BYTE;
{= 通道号 }
    byReserve: BYTE;
    sUserName: array[0..NAME_LEN - 1] of BYTE;
{= 用户名 }
    sPassword: array[0..PASSWD_LEN - 1] of BYTE;
{= 密码 }
    dwPlayMode: LongInt;
{= 0－按文件 1－按时间 }
    StartTime: NET_DVR_TIME;
    StopTime: NET_DVR_TIME;
    sFileName: array[0..128 - 1] of Char;
  end {NET_DVR_MATRIX_DEC_REMOTE_PLAY};
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY;

{+// 文件播放命令*/ }
//const
  //NET_DVR_PLAYSTART =1; {//开始播放}
//const
  //NET_DVR_PLAYSTOP =2;{//停止播放}
//const
  //NET_DVR_PLAYPAUSE =3;{//暂停播放}
//const
  //NET_DVR_PLAYRESTART =4;{//恢复播放}
//const
  //NET_DVR_PLAYFAST =5;{//快放}
//const
 //NET_DVR_PLAYSLOW =6;{//慢放}
//const
  //NET_DVR_PLAYNORMAL =7;{//正常速度}
//const
  //NET_DVR_PLAYSTARTAUDIO =9;{//打开声音}
//const
  //NET_DVR_PLAYSTOPAUDIO = 10;{//关闭声音}
//const
  //NET_DVR_PLAYSETPOS = 12;{//改变文件回放的进度}

type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL = record
    dwSize: LongInt;
    dwPlayCmd: LongInt;
{= 播放命令 见文件播放命令 }
    dwCmdParam: LongInt;
{= 播放命令参数 }
  end {NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL};
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL;

type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS = record
    dwSize: LongInt;
    dwCurMediaFileLen: LongInt;
{= 当前播放的媒体文件长度 }
    dwCurMediaFilePosition: LongInt;
{= 当前播放文件的播放位置 }
    dwCurMediaFileDuration: LongInt;
{= 当前播放文件的总时间 }
    dwCurPlayTime: LongInt;
{= 当前已经播放的时间 }
    dwCurMediaFIleFrames: LongInt;
{= 当前播放文件的总帧数 }
    dwCurDataType: LongInt;
{= 当前传输的数据类型，19-文件头，20-流数据， 21-播放结束标志 }
    res: array[0..72 - 1] of BYTE;
  end {NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS};
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS;
{+//***********************************多路解码器(end)***************************************/ }

type
  NET_DVR_EMAILCFG = record
{= 12 bytes }
    dwSize: LongInt;
    sUserName: array[0..32 - 1] of Char;
    sPassWord: array[0..32 - 1] of Char;
    sFromName: array[0..32 - 1] of Char;
{- Sender* }
{=char sFromAddr[48]; /* Sender address }
    sToName1: array[0..32 - 1] of Char;
{= Receiver1 }
    sToName2: array[0..32 - 1] of Char;
{= Receiver2 }
    sToAddr1: array[0..48 - 1] of Char;
{= Receiver address1 }
    sToAddr2: array[0..48 - 1] of Char;
{= Receiver address2 }
    sEmailServer: array[0..32 - 1] of Char;
{= Email server address }
    byServerType: BYTE;
{= Email server type: 0-SMTP, 1-POP, 2-IMTP… }
    byUseAuthen: BYTE;
{= Email server authentication method: 1-enable, 0-disable }
    byAttachment: BYTE;
{= enable attachment }
    byMailinterval: BYTE;
{= mail interval 0-2s, 1-3s, 2-4s. 3-5s }
  end {NET_DVR_EMAILCFG};
  LPNET_DVR_EMAILCFG = ^NET_DVR_EMAILCFG;

type
  NET_DVR_COMPRESSIONCFG_NEW = record
    dwSize: LongInt;
    struLowCompression: NET_DVR_COMPRESSION_INFO_EX;
    struEventCompression: NET_DVR_COMPRESSION_INFO_EX;
  end {NET_DVR_COMPRESSIONCFG_NEW};
  LPNET_DVR_COMPRESSIONCFG_NEW = ^NET_DVR_COMPRESSIONCFG_NEW;

{///球机位置信息 }
type
  NET_DVR_PTZPOS = record
    wAction: Word;
    wPanPos: Word;
    wTiltPos: Word;
    wZoomPos: Word;
  end {NET_DVR_PTZPOS};
  LPNET_DVR_PTZPOS = ^NET_DVR_PTZPOS;

{///球机范围信息 }
type
  NET_DVR_PTZSCOPE = record
    wPanPosMin: Word;
    wPanPosMax: Word;
    wTiltPosMin: Word;
    wTiltPosMax: Word;
    wZoomPosMin: Word;
    wZoomPosMax: Word;
  end {NET_DVR_PTZSCOPE};
  LPNET_DVR_PTZSCOPE = ^NET_DVR_PTZSCOPE;

{///rtsp配置 ipcamera专用 }
type
  NET_DVR_RTSPCFG = record
    dwSize: LongInt;
    wPort: Word;
    byReserve: array[0..54 - 1] of BYTE;
  end {NET_DVR_RTSPCFG};
  LPNET_DVR_RTSPCFG = ^NET_DVR_RTSPCFG;


{+//*******************************接口参数结构(begin)*********************************/ }

{///NET_DVR_Login()参数结构 }
type
  NET_DVR_DEVICEINFO = record
    sSerialNumber: array[0..SERIALNO_LEN - 1] of BYTE;
    byAlarmInPortNum: BYTE;
    byAlarmOutPortNum: BYTE;
    byDiskNum: BYTE;
    byDVRType: BYTE;
    byChanNum: BYTE;
    byStartChan: BYTE;
  end {NET_DVR_DEVICEINFO};
  LPNET_DVR_DEVICEINFO = ^NET_DVR_DEVICEINFO;

{///NET_DVR_Login_V30()参数结构 }
type
  NET_DVR_DEVICEINFO_V30 = record
    sSerialNumber: array[0..SERIALNO_LEN - 1] of BYTE;
    byAlarmInPortNum: BYTE;
    byAlarmOutPortNum: BYTE;
    byDiskNum: BYTE;
    byDVRType: BYTE;
    byChanNum: BYTE;
    byStartChan: BYTE;
    byAudioChanNum: BYTE;
    byIPChanNum: BYTE;
    byRes1: array[0..24 - 1] of BYTE;
  end {NET_DVR_DEVICEINFO_V30};
  LPNET_DVR_DEVICEINFO_V30 = ^NET_DVR_DEVICEINFO_V30;

{///sdk网络环境枚举变量，用于远程升级 }
type
  _SDK_NET_ENV = (
    LOCAL_AREA_NETWORK = 0,
    WIDE_AREA_NETWORK);
  SDK_NETWORK_ENVIRONMENT = _SDK_NET_ENV;

{///显示模式 }
type
  DISPLAY_MODE = (
    NORMALMODE = 0,
    OVERLAYMODE);

{///发送模式 }
type
  SEND_MODE = (
    PTOPTCPMODE = 0,
    PTOPUDPMODE,
    MULTIMODE,
    RTPMODE,
    RESERVEDMODE);

{///抓图模式 }
type
  CAPTURE_MODE = (
    BMP_MODE = 0,
    JPEG_MODE = 1);

{///实时声音模式 }
type
  REALSOUND_MODE = (
    MONOPOLIZE_MODE = 1,
    SHARE_MODE = 2);

{///软解码预览参数 }
type
  NET_DVR_CLIENTINFO = record
    lChannel: LongInt;
    lLinkMode: LongInt;
    hPlayWnd: HWND;
    sMultiCastIP: PChar;
  end {NET_DVR_CLIENTINFO};
  LPNET_DVR_CLIENTINFO = ^NET_DVR_CLIENTINFO;

{///SDK状态信息(9000新增) }
type
  NET_DVR_SDKSTATE = record
    dwTotalLoginNum: LongInt;
    dwTotalRealPlayNum: LongInt;
    dwTotalPlayBackNum: LongInt;
    dwTotalAlarmChanNum: LongInt;
    dwTotalFormatNum: LongInt;
    dwTotalFileSearchNum: LongInt;
    dwTotalLogSearchNum: LongInt;
    dwTotalSerialNum: LongInt;
    dwTotalUpgradeNum: LongInt;
    dwTotalVoiceComNum: LongInt;
    dwTotalBroadCastNum: LongInt;
    dwRes: array[0..10 - 1] of LongInt;
  end {NET_DVR_SDKSTATE};
  LPNET_DVR_SDKSTATE = ^NET_DVR_SDKSTATE;

{///SDK功能支持信息(9000新增) }
type
  NET_DVR_SDKABL = record
    dwMaxLoginNum: LongInt;
    dwMaxRealPlayNum: LongInt;
    dwMaxPlayBackNum: LongInt;
    dwMaxAlarmChanNum: LongInt;
    dwMaxFormatNum: LongInt;
    dwMaxFileSearchNum: LongInt;
    dwMaxLogSearchNum: LongInt;
    dwMaxSerialNum: LongInt;
    dwMaxUpgradeNum: LongInt;
    dwMaxVoiceComNum: LongInt;
    dwMaxBroadCastNum: LongInt;
    dwRes: array[0..10 - 1] of LongInt;
  end {NET_DVR_SDKABL};
  LPNET_DVR_SDKABL = ^NET_DVR_SDKABL;

{///报警设备信息 }
type
  NET_DVR_ALARMER = record
    byUserIDValid: BYTE;
{= userid是否有效 0-无效，1-有效 }
    bySerialValid: BYTE;
{= 序列号是否有效 0-无效，1-有效 }
    byVersionValid: BYTE;
{= 版本号是否有效 0-无效，1-有效 }
    byDeviceNameValid: BYTE;
{= 设备名字是否有效 0-无效，1-有效 }
    byMacAddrValid: BYTE;
{= MAC地址是否有效 0-无效，1-有效 }
    byLinkPortValid: BYTE;
{= login端口是否有效 0-无效，1-有效 }
    byDeviceIPValid: BYTE;
{= 设备IP是否有效 0-无效，1-有效 }
    bySocketIPValid: BYTE;
{= socket ip是否有效 0-无效，1-有效 }
    lUserID: LongInt;
{= NET_DVR_Login()返回值, 布防时有效 }
    sSerialNumber: array[0..SERIALNO_LEN - 1] of BYTE;
{= 序列号 }
    dwDeviceVersion: LongInt;
{= 版本信息 高16位表示主版本，低16位表示次版本 }
    sDeviceName: array[0..NAME_LEN - 1] of Char;
{= 设备名字 }
    byMacAddr: array[0..MACADDR_LEN - 1] of BYTE;
{= MAC地址 }
    wLinkPort: Word;
{= link port }
    sDeviceIP: array[0..128 - 1] of Char;
{= IP地址 }
    sSocketIP: array[0..128 - 1] of Char;
{= 报警主动上传时的socket IP地址 }
    byIpProtocol: BYTE;
{= Ip协议 0-IPV4, 1-IPV6 }
    byRes2: array[0..11 - 1] of BYTE;
  end {NET_DVR_ALARMER};
  LPNET_DVR_ALARMER = ^NET_DVR_ALARMER;

{///硬解码显示区域参数(子结构) }
type
  NET_DVR_DISPLAY_PARA = record
    bToScreen: LongInt;
    bToVideoOut: LongInt;
    nLeft: LongInt;
    nTop: LongInt;
    nWidth: LongInt;
    nHeight: LongInt;
    nReserved: LongInt;
  end {NET_DVR_DISPLAY_PARA};
  LPNET_DVR_DISPLAY_PARA = ^NET_DVR_DISPLAY_PARA;

{///硬解码预览参数 }
type
  NET_DVR_CARDINFO = record
    lChannel: LongInt;
    lLinkMode: LongInt;
    sMultiCastIP: PChar;
    struDisplayPara: NET_DVR_DISPLAY_PARA;
  end {NET_DVR_CARDINFO};
  LPNET_DVR_CARDINFO = ^NET_DVR_CARDINFO;

{///录象文件参数 }
type
  NET_DVR_FIND_DATA = record
    sFileName: array[0..100 - 1] of Char;
    struStartTime: NET_DVR_TIME;
    struStopTime: NET_DVR_TIME;
    dwFileSize: LongInt;
  end {NET_DVR_FIND_DATA};
  LPNET_DVR_FIND_DATA = ^NET_DVR_FIND_DATA;

{///录象文件参数(9000) }
type
  NET_DVR_FINDDATA_V30 = record
    sFileName: array[0..100 - 1] of Char;
    struStartTime: NET_DVR_TIME;
    struStopTime: NET_DVR_TIME;
    dwFileSize: LongInt;
    sCardNum: array[0..32 - 1] of Char;
    byLocked: BYTE;
    byRes: array[0..3 - 1] of BYTE;
  end {NET_DVR_FINDDATA_V30};
  LPNET_DVR_FINDDATA_V30 = ^NET_DVR_FINDDATA_V30;

{///录象文件参数(带卡号) }
type
  NET_DVR_FINDDATA_CARD = record
    sFileName: array[0..100 - 1] of Char;
    struStartTime: NET_DVR_TIME;
    struStopTime: NET_DVR_TIME;
    dwFileSize: LongInt;
    sCardNum: array[0..32 - 1] of Char;
  end {NET_DVR_FINDDATA_CARD};
  LPNET_DVR_FINDDATA_CARD = ^NET_DVR_FINDDATA_CARD;


{///录象文件查找条件结构 }
type
  NET_DVR_FILECOND = record
    lChannel: LongInt;
    dwFileType: LongInt;
{///3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像 }
    dwIsLocked: LongInt;
    dwUseCardNo: LongInt;
    sCardNumber: array[0..32 - 1] of BYTE;
    struStartTime: NET_DVR_TIME;
    struStopTime: NET_DVR_TIME;
  end {NET_DVR_FILECOND};
  LPNET_DVR_FILECOND = ^NET_DVR_FILECOND;


{///云台区域选择放大缩小(HIK 快球专用) }
type
  NET_DVR_POINT_FRAME = record
    xTop: Integer;
    yTop: Integer;
    xBottom: Integer;
    yBottom: Integer;
    bCounter: Integer;
  end {NET_DVR_POINT_FRAME};
  LPNET_DVR_POINT_FRAME = ^NET_DVR_POINT_FRAME;

{///语音对讲参数 }
type
  NET_DVR_COMPRESSION_AUDIO = record
    byAudioEncType: BYTE;
    byres: array[0..7 - 1] of BYTE;
  end {NET_DVR_COMPRESSION_AUDIO};
  LPNET_DVR_COMPRESSION_AUDIO = ^NET_DVR_COMPRESSION_AUDIO;

{+//*******************************接口参数结构(end)*********************************/ }


{+//*******************************SDK接口函数声明*********************************/ }

function NET_DVR_Init: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_Cleanup: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetDVRMessage(nMessage: Word; hWnd: HWND): BOOL; stdcall; external 'HCNetSDK.dll'
{///NET_DVR_SetDVRMessage的扩展 }


type TfExceptionCallBack = procedure(dwType: Longword; lUserID: Longint; lHandle: Longint; pUser: Pointer); stdcall;
function NET_DVR_SetExceptionCallBack_V30(nMessage: Word;
  hWnd: HWND;
  fExceptionCallBack: TfExceptionCallBack; pUser: Pointer): BOOL; stdcall; external 'HCNetSDK.dll'


type TfMessCallBack = procedure(lCommand: longint; sDVRIP: PChar; pBuf: PChar; dwBufLen: Longword); stdcall;
function NET_DVR_SetDVRMessCallBack(fMessCallBack: TfMessCallBack): BOOL; stdcall; external 'HCNetSDK.dll'

type TfMessCallBack_EX = procedure(lCommand: Longint; lUserID: LongInt; pBuf: PChar; dwBufLen: Longword); stdcall;
function NET_DVR_SetDVRMessCallBack_EX(fMessCallBack_EX: TfMessCallBack_EX): BOOL; stdcall; external 'HCNetSDK.dll'

type TfMessCallBack_NEW = procedure(lCommand: Longint; sDVRIP: PChar; pBuf: PChar; dwBufLen: Longword; dwLinkDVRPort: Word); stdcall;
function NET_DVR_SetDVRMessCallBack_NEW(fMessCallBack_NEW: TfMessCallBack_NEW): BOOL; stdcall; external 'HCNetSDK.dll'

type TfMessageCallBack = procedure(lCommand: Longint; sDVRIP: PChar; pBuf: PChar; dwBufLen: Longword; dwUser: Longword); stdcall;
function NET_DVR_SetDVRMessageCallBack(fMessageCallBack: TfMessageCallBack; dwUser: Longword): BOOL; stdcall; external 'HCNetSDK.dll'

type PNET_DVR_ALARMER = ^NET_DVR_ALARMER;
type MSGCallBack = procedure(lCommand: Longint; pAlarmer: PNET_DVR_ALARMER; pAlarmInfo: PChar; dwBufLen: Longword; pUser: Pointer); stdcall;
function NET_DVR_SetDVRMessageCallBack_V30(fMessageCallBack: MSGCALLBACK; pUser: Pointer): BOOL; stdcall; external 'HCNetSDK.dll'


function NET_DVR_SetConnectTime(dwWaitTime: Longword; dwTryTimes: Longword): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetReconnect(dwInterval: Longword; bEnableRecon: Boolean): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetSDKVersion(): Longword; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetSDKBuildVersion(): Longword; stdcall; external 'HCNetSDK.dll'

function NET_DVR_IsSupport(): integer; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StartListen(sLocalIP: PChar;
  wLocalPort: Word): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StopListen: BOOL; stdcall; external 'HCNetSDK.dll'


function NET_DVR_StartListen_V30(sLocalIP: PChar; wLocalPort: Word; DataCallback: MSGCallBack; pUserData: Pointer): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StopListen_V30(lListenHandle: LongInt): Boolean; stdcall; external 'HCNetSDK.dll'

function NET_DVR_Login(sDVRIP: PChar;
  wDVRPort: Word;
  sUserName: PChar;
  sPassword: PChar;
  lpDeviceInfo: LPNET_DVR_DEVICEINFO): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_Login_V30(sDVRIP: PChar;
  wDVRPort: Word;
  sUserName: PChar;
  sPassword: PChar;
  lpDeviceInfo: LPNET_DVR_DEVICEINFO_V30): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_Logout(lUserID: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_Logout_V30(lUserID: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetLastError: DWORD; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetErrorMsg(pErrorNo: Longint): PChar; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetShowMode(dwShowType: LongInt;
  colorKey: TColorRef): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetDVRIPByResolveSvr(sServerIP: PChar;
  wServerPort: Word;
  var sDVRName: BYTE;
  wDVRNameLen: Word;
  var sDVRSerialNumber: BYTE;
  wDVRSerialLen: Word;
  sGetIP: PChar): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetDVRIPByResolveSvr_EX(sServerIP: PChar;
  wServerPort: Word;
  var sDVRName: Byte;
  wDVRNameLen: Word;
  var sDVRSerialNumber: BYTE;
  wDVRSerialLen: Word;
  sGetIP: PChar;
  var dwPort: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

{///预览相关接口 }

function NET_DVR_RealPlay(lUserID: LongInt; lpClientInfo: LPNET_DVR_CLIENTINFO): Longint; stdcall; external 'HCNetSDK.dll'

//Get the data of the video
type LPByte = ^Byte;

type TfRealDataCallBack_V30 = procedure(lRealHandle: Longint; dwDataType: Longword; pBuffer: LPByte; dwBufSize: Longword; pUser: Pointer); stdcall;

function NET_DVR_RealPlay_V30(lUserID: Longint; lpClientInfo: LPNET_DVR_CLIENTINFO; fRealDataCallBack_V30: TfRealDataCallBack_V30; pUser: Pointer; bBlocked: Boolean): Longint; stdcall; external 'HCNetSDK.dll';

 //Stop Video
function NET_DVR_StopRealPlay(lRealHandle: Longint): Boolean; stdcall; external 'HCNetSDK.dll'

type TfDrawFun = procedure(lRealHandle: longint; hDc: Pointer; dwUser: Longword); stdcall;
function NET_DVR_RigisterDrawFun(lRealHandle: longint; fDrawFun: TfDrawFun): Boolean; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetPlayerBufNumber(lRealHandle: LongInt; dwBufNum: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ThrowBFrame(lRealHandle: LongInt;
  dwNum: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetAudioMode(dwMode: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_OpenSound(lRealHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_CloseSound: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_OpenSoundShare(lRealHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_CloseSoundShare(lRealHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_Volume(lRealHandle: LongInt;
  wVolume: Word): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SaveRealData(lRealHandle: LongInt;
  sFileName: PChar): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StopSaveRealData(lRealHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'


type TfRealDataCallBack = procedure(lRealHandle: Longint; dwDataType: Longword; pBuffer: LPByte; dwBufSize: Longword; dwUser: Longword); stdcall;
function NET_DVR_SetRealDataCallBack(lRealHandle: LongInt; fRealDataCallBack: TfRealDataCallBack; dwUser: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

type TfStdDataCallBack = procedure(lRealHandle: Longint; dwDataType: Longword; pBuffer: LPByte; dwBufSize: Longword; dwUser: Longword); stdcall;
function NET_DVR_SetStandardDataCallBack(lRealHandle: LongInt; fRealDataCallBack: TfRealDataCallBack; dwUser: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'


function NET_DVR_CapturePicture(lRealHandle: LongInt;
  sPicFileName: PChar): BOOL; stdcall; external 'HCNetSDK.dll'

{///动态生成I帧 }

function NET_DVR_MakeKeyFrame(lUserID: LongInt;
  lChannel: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MakeKeyFrameSub(lUserID: LongInt;
  lChannel: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

{///云台控制相关接口 }

function NET_DVR_PTZControl(lRealHandle: LongInt;
  dwPTZCommand: LongInt;
  dwStop: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZControl_Other(lUserID: LongInt;
  lChannel: LongInt;
  dwPTZCommand: LongInt;
  dwStop: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_TransPTZ(lRealHandle: LongInt;
  pPTZCodeBuf: PChar;
  dwBufSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_TransPTZ_Other(lUserID: LongInt;
  lChannel: LongInt;
  pPTZCodeBuf: PChar;
  dwBufSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZPreset(lRealHandle: LongInt;
  dwPTZPresetCmd: LongInt;
  dwPresetIndex: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZPreset_Other(lUserID: LongInt;
  lChannel: LongInt;
  dwPTZPresetCmd: LongInt;
  dwPresetIndex: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_TransPTZ_EX(lRealHandle: LongInt;
  pPTZCodeBuf: PChar;
  dwBufSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZControl_EX(lRealHandle: LongInt;
  dwPTZCommand: LongInt;
  dwStop: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZPreset_EX(lRealHandle: LongInt;
  dwPTZPresetCmd: LongInt;
  dwPresetIndex: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZCruise(lRealHandle: LongInt;
  dwPTZCruiseCmd: LongInt;
  byCruiseRoute: BYTE;
  byCruisePoint: BYTE;
  wInput: Word): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZCruise_Other(lUserID: LongInt;
  lChannel: LongInt;
  dwPTZCruiseCmd: LongInt;
  byCruiseRoute: BYTE;
  byCruisePoint: BYTE;
  wInput: Word): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZCruise_EX(lRealHandle: LongInt;
  dwPTZCruiseCmd: LongInt;
  byCruiseRoute: BYTE;
  byCruisePoint: BYTE;
  wInput: Word): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZTrack(lRealHandle: LongInt;
  dwPTZTrackCmd: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZTrack_Other(lUserID: LongInt;
  lChannel: LongInt;
  dwPTZTrackCmd: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZTrack_EX(lRealHandle: LongInt;
  dwPTZTrackCmd: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZControlWithSpeed(lRealHandle: LongInt;
  dwPTZCommand: LongInt;
  dwStop: LongInt;
  dwSpeed: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZControlWithSpeed_Other(lUserID: LongInt;
  lChannel: LongInt;
  dwPTZCommand: LongInt;
  dwStop: LongInt;
  dwSpeed: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZControlWithSpeed_EX(lRealHandle: LongInt;
  dwPTZCommand: LongInt;
  dwStop: LongInt;
  dwSpeed: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetPTZCruise(lUserID: LongInt;
  lChannel: LongInt;
  lCruiseRoute: LongInt;
  var lpCruiseRet: NET_DVR_CRUISE_RET): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZMltTrack(lRealHandle: LongInt;
  dwPTZTrackCmd: LongInt;
  dwTrackIndex: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZMltTrack_Other(lUserID: LongInt;
  lChannel: LongInt;
  dwPTZTrackCmd: LongInt;
  dwTrackIndex: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZMltTrack_EX(lRealHandle: LongInt;
  dwPTZTrackCmd: LongInt;
  dwTrackIndex: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

{///文件查找与回放 }

function NET_DVR_FindFile(lUserID: LongInt;
  lChannel: LongInt;
  dwFileType: LongInt;
  var lpStartTime: NET_DVR_TIME;
  var lpStopTime: NET_DVR_TIME): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindNextFile(lFindHandle: LongInt;
  var lpFindData: NET_DVR_FIND_DATA): longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindClose(lFindHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindNextFile_V30(lFindHandle: LongInt;
  var lpFindData: NET_DVR_FINDDATA_V30): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindFile_V30(lUserID: LongInt;
  var pFindCond: NET_DVR_FILECOND): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindClose_V30(lFindHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///2007-04-16增加查询结果带卡号的文件查找 }

function NET_DVR_FindNextFile_Card(lFindHandle: LongInt;
  var lpFindData: NET_DVR_FINDDATA_CARD): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindFile_Card(lUserID: LongInt;
  lChannel: LongInt;
  dwFileType: LongInt;
  var lpStartTime: NET_DVR_TIME;
  var lpStopTime: NET_DVR_TIME): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_LockFileByName(lUserID: LongInt;
  sLockFileName: PChar): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_UnlockFileByName(lUserID: LongInt;
  sUnlockFileName: PChar): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PlayBackByName(lUserID: LongInt;
  sPlayBackFileName: PChar;
  hWnd: HWND): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PlayBackByTime(lUserID: LongInt;
  lChannel: LongInt;
  var lpStartTime: NET_DVR_TIME;
  var lpStopTime: NET_DVR_TIME;
  hWnd: HWND): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PlayBackControl(lPlayHandle: LongInt;
  dwControlCode: LongInt;
  dwInValue: LongInt;
  var LPOutValue: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StopPlayBack(lPlayHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

type TfPlayDataCallBack = procedure(lPlayHandle: Longint;
    dwDataType: LongInt;
    pBuffer: LPByte;
    dwBufSize: Longword;
    dwUser: Longword); stdcall;
function NET_DVR_SetPlayDataCallBack(lPlayHandle: LongInt;
  fPlayDataCallBack: TfPlayDataCallBack;
  dwUser: Longword): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PlayBackSaveData(lPlayHandle: LongInt;
  sFileName: PChar): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StopPlayBackSave(lPlayHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetPlayBackOsdTime(lPlayHandle: LongInt;
  var lpOsdTime: NET_DVR_TIME): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PlayBackCaptureFile(lPlayHandle: LongInt;
  sFileName: PChar): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetFileByName(lUserID: LongInt;
  sDVRFileName: PChar;
  sSavedFileName: PChar): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetFileByTime(lUserID: LongInt;
  lChannel: LongInt;
  var lpStartTime: NET_DVR_TIME;
  var lpStopTime: NET_DVR_TIME;
  sSavedFileName: PChar): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StopGetFile(lFileHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetDownloadPos(lFileHandle: LongInt): integer; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetPlayBackPos(lPlayHandle: LongInt): integer; stdcall; external 'HCNetSDK.dll'

{///升级 }

function NET_DVR_Upgrade(lUserID: LongInt;
  sFileName: PChar): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetUpgradeState(lUpgradeHandle: LongInt): integer; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetUpgradeProgress(lUpgradeHandle: LongInt): integer; stdcall; external 'HCNetSDK.dll'

function NET_DVR_CloseUpgradeHandle(lUpgradeHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetNetworkEnvironment(dwEnvironmentLevel: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///远程格式化硬盘 }

function NET_DVR_FormatDisk(lUserID: LongInt;
  lDiskNumber: LongInt): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetFormatProgress(lFormatHandle: LongInt;
  var pCurrentFormatDisk: LongInt;
  var pCurrentDiskPos: LongInt;
  var pFormatStatic: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_CloseFormatHandle(lFormatHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///报警 }

function NET_DVR_SetupAlarmChan(lUserID: LongInt): LONGint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_CloseAlarmChan(lAlarmHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetupAlarmChan_V30(lUserID: LongInt): LONGint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_CloseAlarmChan_V30(lAlarmHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///语音对讲 }


type TfVoiceDataCallBack = procedure(lVoiceComHandle: longint;
    pRecvDataBuffer: PChar;
    dwBufSize: LongInt;
    byAudioFlag: BYTE;
    dwUser: Longword); stdcall;
function NET_DVR_StartVoiceCom(lUserID: LongInt;
  fVoiceDataCallBack: TfVoiceDataCallBack;
  dwUser: Longword): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StartVoiceCom_V30(lUserID: LongInt;
  dwVoiceChan: Longword;
  bNeedCBNoEncData: Boolean;
  fVoiceDataCallBack: TfVoiceDataCallBack;
  pUser: Pointer): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetVoiceComClientVolume(lVoiceComHandle: LongInt;
  wVolume: Word): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StopVoiceCom(lVoiceComHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///语音转发 }

function NET_DVR_StartVoiceCom_MR(lUserID: LongInt;
  fVoiceDataCallBack: TfVoiceDataCallBack;
  dwUser: LongInt): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StartVoiceCom_MR_V30(lUserID: LongInt;
  dwVoiceChan: LongInt;
  fVoiceDataCallBack: TfVoiceDataCallBack;
  pUser: Pointer): Longint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_VoiceComSendData(lVoiceComHandle: LongInt;
  pSendBuf: PChar;
  dwBufSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

{///语音广播 }

function TNET_DVR_ClientAudioStart: BOOL; stdcall; external 'HCNetSDK.dll'

type TfVoiceDataCallBack_Multi = procedure(pRecvDataBuffer: PChar; dwBufSize: Longword; pUser: Pointer); stdcall;
function NET_DVR_ClientAudioStart_V30(
  fVoiceDataCallBack: TfVoiceDataCallBack_Multi;
  pUser: Pointer): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ClientAudioStop: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_AddDVR(lUserID: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_AddDVR_V30(lUserID: LongInt;
  dwVoiceChan: LongInt): LONGint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_DelDVR(lUserID: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_DelDVR_V30(lVoiceHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///////////////////////////////////////////////////////////// }
{///透明通道设置 }

type TfSerialDataCallBack = procedure(lSerialHandle: Longint;
    pRecvDataBuffer: PChar;
    dwBufSize: Longword;
    dwUser: Longint); stdcall;
function NET_DVR_SerialStart(lUserID: LongInt;
  lSerialPort: LongInt;
  fSerialDataCallBack: TfSerialDataCallBack;
  dwUser: Longword): Longint; stdcall; external 'HCNetSDK.dll'
{///485作为透明通道时，需要指明通道号，因为不同通道号485的设置可以不同(比如波特率) }

function NET_DVR_SerialSend(lSerialHandle: LongInt;
  lChannel: LongInt;
  pSendBuf: PChar;
  dwBufSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SerialStop(lSerialHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SendTo232Port(lUserID: LongInt;
  pSendBuf: PChar;
  dwBufSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SendToSerialPort(lUserID: LongInt;
  dwSerialPort: LongInt;
  dwSerialIndex: LongInt;
  pSendBuf: PChar;
  dwBufSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

{///解码 nBitrate = 16000 }

function NET_DVR_InitG722Decoder(nBitrate: integer): Pointer; stdcall; external 'HCNetSDK.dll'

procedure NET_DVR_ReleaseG722Decoder(pDecHandle: Pointer); stdcall; external 'HCNetSDK.dll'

function NET_DVR_DecodeG722Frame(pDecHandle: Pointer;
  var pInBuffer: Byte;
  var pOutBuffer: Byte): BOOL; stdcall; external 'HCNetSDK.dll'
{///编码 }

function NET_DVR_InitG722Encoder(): Pointer; stdcall; external 'HCNetSDK.dll'

function NET_DVR_EncodeG722Frame(pEncodeHandle: Pointer;
  var pInBuffer: Byte;
  var pOutBuffer: Byte): BOOL; stdcall; external 'HCNetSDK.dll'

procedure NET_DVR_ReleaseG722Encoder(pEncodeHandle: Pointer); stdcall; external 'HCNetSDK.dll'

{///远程控制本地显示 }

function NET_DVR_ClickKey(lUserID: LongInt;
  lKeyIndex: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///远程控制设备端手动录像 }

function NET_DVR_StartDVRRecord(lUserID: LongInt;
  lChannel: LongInt;
  lRecordType: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StopDVRRecord(lUserID: LongInt;
  lChannel: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///解码卡 }

function NET_DVR_InitDevice_Card(var pDeviceTotalChan: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ReleaseDevice_Card: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_InitDDraw_Card(hParent: HWND;
  colorKey: TColorRef): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ReleaseDDraw_Card: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_RealPlay_Card(lUserID: LongInt;
  var lpCardInfo: NET_DVR_CARDINFO;
  lChannelNum: LongInt): LONGint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ResetPara_Card(lRealHandle: LongInt;
  var lpDisplayPara: NET_DVR_DISPLAY_PARA): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_RefreshSurface_Card: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ClearSurface_Card: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_RestoreSurface_Card: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_OpenSound_Card(lRealHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_CloseSound_Card(lRealHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetVolume_Card(lRealHandle: LongInt;
  wVolume: Word): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_AudioPreview_Card(lRealHandle: LongInt;
  bEnable: Bool): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetCardLastError_Card: LONGint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetChanHandle_Card(lRealHandle: LongInt): HWND; stdcall; external 'HCNetSDK.dll'

function NET_DVR_CapturePicture_Card(lRealHandle: LongInt;
  sPicFileName: PChar): BOOL; stdcall; external 'HCNetSDK.dll'
{///获取解码卡序列号此接口无效，改用GetBoardDetail接口获得(2005-12-08支持) }

function NET_DVR_GetSerialNum_Card(lChannelNum: LongInt;
  var pDeviceSerialNo: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///日志 }

function NET_DVR_FindDVRLog(lUserID: LongInt;
  lSelectMode: LongInt;
  dwMajorType: LongInt;
  dwMinorType: LongInt;
  var lpStartTime: NET_DVR_TIME;
  var lpStopTime: NET_DVR_TIME): LONGint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindNextLog(lLogHandle: LongInt;
  var lpLogData: NET_DVR_LOG): LONGint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindLogClose(lLogHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindDVRLog_V30(lUserID: LongInt;
  lSelectMode: LongInt;
  dwMajorType: LongInt;
  dwMinorType: LongInt;
  var lpStartTime: NET_DVR_TIME;
  var lpStopTime: NET_DVR_TIME;
  BONLYSMART: Boolean): LONGint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindNextLog_V30(lLogHandle: LongInt;
  var lpLogData: NET_DVR_LOG_V30): LONGint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_FindLogClose_V30(lLogHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///截止2004年8月5日,共113个接口 }
{///ATM DVR }

function NET_DVR_FindFileByCard(lUserID: LongInt;
  lChannel: LongInt;
  dwFileType: LongInt;
  nFindType: Integer;
  var sCardNumber: BYTE;
  var lpStartTime: NET_DVR_TIME;
  var lpStopTime: NET_DVR_TIME): LONGint; stdcall; external 'HCNetSDK.dll'
{///截止2004年10月5日,共116个接口 }

{///编码 }

//function NET_DVR_InitG722Encoder(): Pointer;stdcall;external 'HCNetSDK.dll'

{function NET_DVR_EncodeG722Frame(pEncodeHandle: Pointer;
                                 var pInBuffer: Byte;
                                 var pOutBuffer: Byte):  BOOL ;stdcall;external 'HCNetSDK.dll'}

//procedure NET_DVR_ReleaseG722Encoder(pEncodeHandle: Pointer) ;stdcall;external 'HCNetSDK.dll'
{///2005-09-15 }

function NET_DVR_SetCapturePictureMode(dwCaptureMode: CAPTURE_MODE): Boolean;
stdcall; external 'HCNetSDK.dll';

function NET_DVR_CaptureJPEGPicture(lUserID: LongInt;
  lChannel: LongInt;
  var lpJpegPara: NET_DVR_JPEGPARA;
  sPicFileName: PChar): BOOL; stdcall; external 'HCNetSDK.dll'
{///JPEG抓图到内存 }

function NET_DVR_CaptureJPEGPicture_NEW(lUserID: LongInt;
  lChannel: LongInt;
  var lpJpegPara: NET_DVR_JPEGPARA;
  sJpegPicBuffer: PChar;
  dwPicSize: LongInt;
  var lpSizeReturned: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'


{///2006-02-16 }

function NET_DVR_GetRealPlayerIndex(lRealHandle: LongInt): integer; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetPlayBackPlayerIndex(lPlayHandle: LongInt): integer; stdcall; external 'HCNetSDK.dll'

{///2006-08-28 704-640 缩放配置 }

function NET_DVR_SetScaleCFG(lUserID: LongInt;
  dwScale: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetScaleCFG(lUserID: LongInt;
  var lpOutScale: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetScaleCFG_V30(lUserID: LongInt;
  var pScalecfg: NET_DVR_SCALECFG): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetScaleCFG_V30(lUserID: LongInt;
  var pScalecfg: NET_DVR_SCALECFG): BOOL; stdcall; external 'HCNetSDK.dll'
{///2006-08-28 ATM机端口设置 }

function NET_DVR_SetATMPortCFG(lUserID: LongInt;
  wATMPort: Word): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetATMPortCFG(lUserID: LongInt;
  var LPOutATMPort: Word): BOOL; stdcall; external 'HCNetSDK.dll'

{///2006-11-10 支持显卡辅助输出 }

function NET_DVR_InitDDrawDevice: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ReleaseDDrawDevice: BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetDDrawDeviceTotalNums: LONGint; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetDDrawDevice(lPlayPort: LongInt;
  nDeviceNum: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'


function NET_DVR_PTZSelZoomIn(lRealHandle: LongInt;
  var pStruPointFrame: NET_DVR_POINT_FRAME): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_PTZSelZoomIn_EX(lUserID: LongInt;
  lChannel: LongInt;
  var pStruPointFrame: NET_DVR_POINT_FRAME): BOOL; stdcall; external 'HCNetSDK.dll'



{///解码设备DS-6001D/DS-6001F }

function NET_DVR_StartDecode(lUserID: LongInt;
  lChannel: LongInt;
  var lpDecoderinfo: NET_DVR_DECODERINFO): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StopDecode(lUserID: LongInt;
  lChannel: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetDecoderState(lUserID: LongInt;
  lChannel: LongInt;
  var lpDecoderState: NET_DVR_DECODERSTATE): BOOL; stdcall; external 'HCNetSDK.dll'
{///2005-08-01 }

function NET_DVR_SetDecInfo(lUserID: LongInt;
  lChannel: LongInt;
  var lpDecoderinfo: NET_DVR_DECCFG): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetDecInfo(lUserID: LongInt;
  lChannel: LongInt;
  var lpDecoderinfo: NET_DVR_DECCFG): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetDecTransPort(lUserID: LongInt;
  var lpTransPort: NET_DVR_PORTCFG): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetDecTransPort(lUserID: LongInt;
  var lpTransPort: NET_DVR_PORTCFG): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_DecPlayBackCtrl(lUserID: LongInt;
  lChannel: LongInt;
  dwControlCode: LongInt;
  dwInValue: LongInt;
  var LPOutValue: LongInt;
  var lpRemoteFileInfo: NET_DVR_PLAYREMOTEFILE): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StartDecSpecialCon(lUserID: LongInt;
  lChannel: LongInt;
  var lpDecChanInfo: NET_DVR_DECCHANINFO): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_StopDecSpecialCon(lUserID: LongInt;
  lChannel: LongInt;
  var lpDecChanInfo: NET_DVR_DECCHANINFO): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_DecCtrlDec(lUserID: LongInt;
  lChannel: LongInt;
  dwControlCode: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_DecCtrlScreen(lUserID: LongInt;
  lChannel: LongInt;
  dwControl: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetDecCurLinkStatus(lUserID: LongInt;
  lChannel: LongInt;
  var lpDecStatus: NET_DVR_DECSTATUS): BOOL; stdcall; external 'HCNetSDK.dll'

{///多路解码器 }
{///2007-11-30 V211支持以下接口 //11 }

function NET_DVR_MatrixStartDynamic(lUserID: LongInt;
  dwDecChanNum: LongInt;
  var lpDynamicInfo: NET_DVR_MATRIX_DYNAMIC_DEC): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixStopDynamic(lUserID: LongInt;
  dwDecChanNum: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixGetDecChanInfo(lUserID: LongInt;
  dwDecChanNum: LongInt;
  var lpInter: NET_DVR_MATRIX_DEC_CHAN_INFO): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixSetLoopDecChanInfo(lUserID: LongInt;
  dwDecChanNum: LongInt;
  var lpInter: NET_DVR_MATRIX_LOOP_DECINFO): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixGetLoopDecChanInfo(lUserID: LongInt;
  dwDecChanNum: LongInt;
  var lpInter: NET_DVR_MATRIX_LOOP_DECINFO): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixSetLoopDecChanEnable(lUserID: LongInt;
  dwDecChanNum: LongInt;
  dwEnable: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixGetLoopDecChanEnable(lUserID: LongInt;
  dwDecChanNum: LongInt;
  var lpdwEnable: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixGetLoopDecEnable(lUserID: LongInt;
  var lpdwEnable: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixSetDecChanEnable(lUserID: LongInt;
  dwDecChanNum: LongInt;
  dwEnable: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixGetDecChanEnable(lUserID: LongInt;
  dwDecChanNum: LongInt;
  var lpdwEnable: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixGetDecChanStatus(lUserID: LongInt;
  dwDecChanNum: LongInt;
  var lpInter: NET_DVR_MATRIX_DEC_CHAN_STATUS): BOOL; stdcall; external 'HCNetSDK.dll'
{///2007-12-22 增加支持接口 //18 }

function NET_DVR_MatrixSetTranInfo(lUserID: LongInt;
  var lpTranInfo: NET_DVR_MATRIX_TRAN_CHAN_CONFIG): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixGetTranInfo(lUserID: LongInt;
  var lpTranInfo: NET_DVR_MATRIX_TRAN_CHAN_CONFIG): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixSetRemotePlay(lUserID: LongInt;
  dwDecChanNum: LongInt;
  var lpInter: NET_DVR_MATRIX_DEC_REMOTE_PLAY): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixSetRemotePlayControl(lUserID: LongInt;
  dwDecChanNum: LongInt;
  dwControlCode: LongInt;
  dwInValue: LongInt;
  var LPOutValue: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_MatrixGetRemotePlayStatus(lUserID: LongInt;
  dwDecChanNum: LongInt;
  var lpOuter: NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS): BOOL; stdcall; external 'HCNetSDK.dll'
{///end }

function NET_DVR_RefreshPlay(lPlayHandle: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///恢复默认值 }

function NET_DVR_RestoreConfig(lUserID: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///保存参数 }

function NET_DVR_SaveConfig(lUserID: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///重启 }

function NET_DVR_RebootDVR(lUserID: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'
{///关闭DVR }

function NET_DVR_ShutDownDVR(lUserID: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'



{///参数配置 begin }

function NET_DVR_GetDVRConfig(lUserID: LongInt;
  dwCommand: LongInt;
  lChannel: LongInt;
  var lpOutBuffer: Pointer;
  dwOutBufferSize: LongInt;
  var lpBytesReturned: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetDVRConfig(lUserID: LongInt;
  dwCommand: LongInt;
  lChannel: LongInt;
  var lpInBuffer: Pointer;
  dwInBufferSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetDVRWorkState_V30(lUserID: LongInt;
  var lpWorkState: NET_DVR_WORKSTATE_V30): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetDVRWorkState(lUserID: LongInt;
  var lpWorkState: NET_DVR_WORKSTATE): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetVideoEffect(lUserID: LongInt;
  lChannel: LongInt;
  dwBrightValue: LongInt;
  dwContrastValue: LongInt;
  dwSaturationValue: LongInt;
  dwHueValue: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetVideoEffect(lUserID: LongInt;
  lChannel: LongInt;
  var pBrightValue: LongInt;
  var pContrastValue: LongInt;
  var pSaturationValue: LongInt;
  var pHueValue: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ClientGetframeformat(lUserID: LongInt;
  var lpFrameFormat: NET_DVR_FRAMEFORMAT): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ClientSetframeformat(lUserID: LongInt;
  var lpFrameFormat: NET_DVR_FRAMEFORMAT): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ClientGetframeformat_V30(lUserID: LongInt;
  var lpFrameFormat: NET_DVR_FRAMEFORMAT_V30): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ClientSetframeformat_V30(lUserID: LongInt;
  var lpFrameFormat: NET_DVR_FRAMEFORMAT_V30): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetAlarmOut_V30(lUserID: LongInt;
  var lpAlarmOutState: NET_DVR_ALARMOUTSTATUS_V30): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetAlarmOut(lUserID: LongInt;
  var lpAlarmOutState: NET_DVR_ALARMOUTSTATUS): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetAlarmOut(lUserID: LongInt;
  lAlarmOutPort: LongInt;
  lAlarmOutStatic: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

{///视频参数调节 }

function NET_DVR_ClientSetVideoEffect(lRealHandle: LongInt;
  dwBrightValue: LongInt;
  dwContrastValue: LongInt;
  dwSaturationValue: LongInt;
  dwHueValue: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_ClientGetVideoEffect(lRealHandle: LongInt;
  var pBrightValue: LongInt;
  var pContrastValue: LongInt;
  var pSaturationValue: LongInt;
  var pHueValue: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

{///配置文件 }

function NET_DVR_GetConfigFile(lUserID: LongInt;
  sFileName: PChar): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetConfigFile(lUserID: LongInt;
  sFileName: PChar): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetConfigFile_V30(lUserID: LongInt;
  sOutBuffer: PChar;
  dwOutSize: LongInt;
  var pReturnSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'


function NET_DVR_GetConfigFile_EX(lUserID: LongInt;
  sOutBuffer: PChar;
  dwOutSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetConfigFile_EX(lUserID: LongInt;
  sInBuffer: PChar;
  dwInSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

{///启用日志文件写入接口 }

function NET_DVR_SetLogToFile(BLOGENABLE: Boolean;
  STRLOGDIR: PChar;
  BAUTODEL: Boolean): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetSDKState(var pSDKState: NET_DVR_SDKSTATE): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetSDKAbility(var pSDKAbl: NET_DVR_SDKABL): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetPTZProtocol(lUserID: LongInt;
  var pPtzcfg: NET_DVR_PTZCFG): BOOL; stdcall; external 'HCNetSDK.dll'
{///前面板锁定 }

function NET_DVR_LockPanel(lUserID: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_UnLockPanel(lUserID: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'


function NET_DVR_SetRtspConfig(lUserID: LongInt;
  dwCommand: LongInt;
  var lpInBuffer: NET_DVR_RTSPCFG;
  dwInBufferSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

function NET_DVR_GetRtspConfig(lUserID: LongInt;
  dwCommand: LongInt;
  var lpOutBuffer: NET_DVR_RTSPCFG;
  dwOutBufferSize: LongInt): BOOL; stdcall; external 'HCNetSDK.dll'

{$ENDIF //}

implementation


end.

